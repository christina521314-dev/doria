<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="screen-orientation" content="landscape">
    <meta name="mobile-web-app-capable" content="yes">
    <title>æŠ“è•‰çŒ´ - æ¸¸æˆDemo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            touch-action: none;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            padding: 20px;
        }

        .game-container {
            background: #2c3e50;
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* æ‰‹æœºæ¨ªå±ä¼˜åŒ–ï¼šç§»é™¤è¾¹è·å’Œåœ†è§’ï¼Œè®©æ¸¸æˆå æ»¡å±å¹• */
        @media (max-width: 900px) and (orientation: landscape) {
            body {
                padding: 0;
            }
            
            .game-container {
                border-radius: 0;
                padding: 0;
                width: 100vw;
                height: 100vh;
                box-shadow: none;
            }
        }

        .game-canvas-wrapper {
            position: relative;
            background: #34495e;
            border: 4px solid #34495e;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.3);
            /* å›ºå®šæ¸¸æˆé€»è¾‘å°ºå¯¸ */
            width: 1280px;
            height: 720px;
            /* ç­‰æ¯”ç¼©æ”¾é€‚é… */
            max-width: 100%;
            max-height: calc(100vh - 80px);
        }

        /* æ‰‹æœºæ¨ªå±ï¼šè®©æ¸¸æˆå æ»¡æ•´ä¸ªå±å¹• */
        @media (max-width: 900px) and (orientation: landscape) {
            .game-canvas-wrapper {
                border: none;
                border-radius: 0;
                width: 100vw;
                height: 100vh;
                max-width: 100vw;
                max-height: 100vh;
            }
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            /* ä¿æŒå®½é«˜æ¯” */
            object-fit: contain;
            touch-action: none;
        }

        /* æ‰‹æœºæ¨ªå±ï¼šcanvasä¿æŒå®½é«˜æ¯”ï¼Œå°½å¯èƒ½å¤§ */
        @media (max-width: 900px) and (orientation: landscape) {
            #gameCanvas {
                width: 100%;
                height: 100%;
                object-fit: contain;  /* ä¿æŒå®½é«˜æ¯”ï¼Œå®Œæ•´æ˜¾ç¤º */
            }
        }

        .game-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            color: white;
            font-size: 2em;
            z-index: 100;
            border-radius: 10px;
            pointer-events: none; /* é»˜è®¤å…è®¸ç‚¹å‡»ç©¿é€åˆ°canvas */
        }
        
        .game-overlay.show {
            pointer-events: none; /* æ˜¾ç¤ºæ—¶ä¹Ÿå…è®¸ç‚¹å‡»ç©¿é€ï¼Œè®©canvasä¸Šçš„æŒ‰é’®å¯ä»¥ç‚¹å‡» */
        }

        .game-overlay.show {
            display: flex;
        }

        .overlay-message {
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            text-align: center;
            padding: 0 20px;
        }

        .victory {
            color: #f1c40f;
        }

        .defeat {
            color: #e74c3c;
        }

        @media (max-width: 1400px) {
            .game-canvas-wrapper {
                transform: scale(0.9);
                transform-origin: top center;
            }
        }

        @media (max-width: 1200px) {
            .game-canvas-wrapper {
                transform: scale(0.85);
            }
        }

        /* æ‰‹æœºæ¨ªå±ï¼šç§»é™¤ç¼©æ”¾ï¼Œè®©æ¸¸æˆå æ»¡å±å¹• */
        @media (max-width: 900px) and (orientation: landscape) {
            .game-canvas-wrapper {
                width: 100vw !important;
                height: 100vh !important;
                max-width: 100vw !important;
                max-height: 100vh !important;
                transform: none !important;
                transform-origin: center;
            }
            
            #gameCanvas {
                width: 100vw !important;
                height: 100vh !important;
            }
        }

        /* æ‰‹æœºç«–å±ï¼šä¿æŒè¾ƒå°ç¼©æ”¾ */
        @media (max-width: 900px) and (orientation: portrait) {
            .game-canvas-wrapper {
                transform: scale(0.5);
            }
        }

        /* æ¨ªå±æç¤º */
        .landscape-prompt {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 10000;
            color: white;
            font-size: 24px;
            text-align: center;
            padding: 20px;
        }

        .landscape-prompt.show {
            display: flex;
        }

        .landscape-prompt-icon {
            font-size: 80px;
            margin-bottom: 30px;
            animation: rotate 2s infinite;
        }

        @keyframes rotate {
            0%, 100% { transform: rotate(0deg); }
            50% { transform: rotate(90deg); }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-canvas-wrapper">
            <canvas id="gameCanvas"></canvas>
            <div class="game-overlay" id="gameOverlay">
                <div class="overlay-message" id="overlayMessage"></div>
            </div>
        </div>
    </div>

    <!-- æ¨ªå±æç¤º -->
    <div class="landscape-prompt" id="landscapePrompt">
        <div class="landscape-prompt-icon">ğŸ“±</div>
        <div style="font-size: 32px; font-weight: bold; margin-bottom: 20px;">è¯·æ¨ªå±æ¸¸æˆ</div>
        <div style="font-size: 20px;">è¯·å°†æ‰‹æœºæ—‹è½¬è‡³æ¨ªå±æ¨¡å¼<br/>ä»¥è·å¾—æœ€ä½³æ¸¸æˆä½“éªŒ</div>
    </div>

    <script src="main.js?v=2.7"></script>
    <script>
        // ========== èƒŒæ™¯å›¾ç‰‡é…ç½®ï¼ˆç¬¬231è¡Œå¼€å§‹ - å¯è‡ªå®šä¹‰è°ƒæ•´ï¼‰ ==========
        // è¿œã€ä¸­ã€è¿‘æ™¯çš„ä½ç½®å’Œå°ºå¯¸é…ç½®
        // è°ƒæ•´è¯´æ˜ï¼š
        //   - x, y: å›¾ç‰‡ç»˜åˆ¶ä½ç½®ï¼ˆx: å·¦å³åç§»ï¼Œy: ä¸Šä¸‹åç§»ï¼‰
        //   - width, height: å›¾ç‰‡ç»˜åˆ¶å°ºå¯¸ï¼ˆå¦‚æœè®¾ä¸ºnullï¼Œåˆ™ä½¿ç”¨å›¾ç‰‡åŸå§‹å°ºå¯¸æˆ–GAME_WIDTH/GAME_HEIGHTï¼‰
        //   - åœ°é¢ä½ç½®ï¼šGAME_HEIGHT - 100 = 620
        // èƒŒæ™¯åç§»å‚æ•°é…ç½®ï¼ˆç¬¬236è¡Œå¼€å§‹ - å¯è‡ªå®šä¹‰è°ƒæ•´ï¼‰
        // è°ƒæ•´è¯´æ˜ï¼š
        //   - x: å·¦å³åç§»ï¼ˆæ­£æ•°å‘å³ï¼Œè´Ÿæ•°å‘å·¦ï¼‰
        //   - y: ä¸Šä¸‹åç§»ï¼ˆæ­£æ•°å‘ä¸‹ï¼Œè´Ÿæ•°å‘ä¸Šï¼‰
        //   - åœ°é¢ä½ç½®ï¼šGAME_HEIGHT - 100 = 620px
        // ================================================
        
        // ========== æ¸¸æˆé…ç½®å‚æ•°ï¼ˆå¯æ‰‹åŠ¨è°ƒæ•´ï¼‰ ==========
        // é™·é˜±ç›¸é‚»æœ€å°è·ç¦»ï¼ˆåƒç´ ï¼‰- å¢å¤§æ­¤å€¼å¯ä»¥è®©é™·é˜±ä¹‹é—´è·ç¦»æ›´è¿œ
        const TRAP_MIN_DISTANCE = 250; // ä»200å¢åŠ åˆ°250ï¼Œè®©é—´è·æ›´å¤§
        // é™·é˜±ä½ç½®éšæœºåç§»èŒƒå›´ï¼ˆåƒç´ ï¼‰- å¢å¤§æ­¤å€¼å¯ä»¥è®©é™·é˜±ä½ç½®æ›´éšæœºï¼Œé¿å…è¿‡äºå¹³å‡
        const TRAP_RANDOM_OFFSET = 400; // é»˜è®¤400åƒç´ ï¼Œå¯æ ¹æ®éœ€è¦è°ƒæ•´ï¼ˆ0è¡¨ç¤ºä¸éšæœºï¼‰
        // é™·é˜±é—´è·éšæœºå€æ•°èŒƒå›´ - [min, max]ï¼Œå€¼è¶Šå¤§é—´è·è¶Šéšæœº
        const TRAP_SPACING_RANDOM_MIN = 0.2; // æœ€å°å€æ•°ï¼ˆæ›´å°çš„å€¼å…è®¸æ›´çŸ­çš„é—´è·ï¼‰
        const TRAP_SPACING_RANDOM_MAX = 3.5; // æœ€å¤§å€æ•°ï¼ˆæ›´å¤§çš„å€¼å…è®¸æ›´é•¿çš„é—´è·ï¼‰
        // ç›¸é‚»é™·é˜±é—´è·æœ€å°å·®å¼‚ï¼ˆåƒç´ ï¼‰- ç¡®ä¿ç›¸é‚»é™·é˜±é—´è·å·®å¼‚æ˜æ˜¾
        const TRAP_DISTANCE_MIN_DIFF = 120; // ç›¸é‚»é™·é˜±é—´è·è‡³å°‘ç›¸å·®80åƒç´ ï¼Œè®©å·®å¼‚æ›´æ˜æ˜¾
        
        // ================================================
        
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameOverlay = document.getElementById('gameOverlay');
        const overlayMessage = document.getElementById('overlayMessage');
        const landscapePrompt = document.getElementById('landscapePrompt');

        // å›ºå®šæ¸¸æˆé€»è¾‘å°ºå¯¸ï¼ˆä½¿ç”¨é…ç½®ï¼‰
        const GAME_WIDTH = GAME_CONFIG.width;
        const GAME_HEIGHT = GAME_CONFIG.height;

        // è®¡ç®—åœ°é¢Yåæ ‡ï¼ˆåŸºäºé…ç½®ï¼‰
        const GROUND_Y = GAME_HEIGHT - GROUND_CONFIG.offsetFromBottom;

        // è°ƒè¯•ï¼šéªŒè¯é…ç½®æ˜¯å¦æ­£ç¡®åŠ è½½
        console.log('=== æ¸¸æˆé…ç½®åŠ è½½æ£€æŸ¥ ===');
        console.log('ç©å®¶å°ºå¯¸:', PLAYER_CONFIG.width, 'x', PLAYER_CONFIG.height);
        console.log('ç›®æ ‡çŒ´å­å°ºå¯¸:', TARGET_MONKEY_CONFIG.width, 'x', TARGET_MONKEY_CONFIG.height);
        console.log('æ™®é€šçŒ´å­å°ºå¯¸:', NORMAL_MONKEY_CONFIG.width, 'x', NORMAL_MONKEY_CONFIG.height);
        console.log('å±±è„‰Yä½ç½®:', BACKGROUND_CONFIG.mid.y);
        console.log('åœ°é¢Yä½ç½®:', GROUND_Y);
        console.log('========================');

        // èƒŒæ™¯å›¾ç‰‡å¯¹è±¡ï¼ˆåªä¿ç•™ä¸­æ™¯ï¼‰
        const backgroundImages = {
            mid: null    // ä¸­æ™¯ bg_mï¼ˆå±±è„‰å±‚ï¼‰
        };

        // ç©å®¶å›¾ç‰‡å¯¹è±¡
        const heroStayImg = new Image();
        heroStayImg.src = 'hero_stay.png?v=' + Date.now();
        const heroWorkImg = new Image();
        heroWorkImg.src = 'hero_work.png?v=' + Date.now();

        // æ™®é€šçŒ´å­å›¾ç‰‡å¯¹è±¡
        const fakeMonkeyImg = new Image();
        fakeMonkeyImg.src = 'fake monkey.png?v=' + Date.now();

        // ç›®æ ‡çŒ´å­å›¾ç‰‡å¯¹è±¡
        const targetMonkeyStayImg = new Image();
        targetMonkeyStayImg.src = 'monkey_stay.png?v=' + Date.now();
        const targetMonkeyRunImg = new Image();
        targetMonkeyRunImg.src = 'monkey_run.png?v=' + Date.now();

        // é¦™è•‰æ ‘å›¾ç‰‡å¯¹è±¡
        const treeImg = new Image();
        treeImg.src = 'tree.png?v=' + Date.now();

        // é™·é˜±å›¾ç‰‡å¯¹è±¡
        const trapImg = new Image();
        trapImg.src = 'trap.png?v=' + Date.now();

        // ç¡®ä¿å›¾ç‰‡åŠ è½½å®Œå†æ¸²æŸ“ï¼Œé˜²æ­¢"æ¸¸æˆä¸åŠ¨"
        let assetsLoaded = 0;
        const totalGameAssets = 7; // ç©å®¶2å¼  + æ™®é€šçŒ´å­1å¼  + ç›®æ ‡çŒ´å­2å¼  + é¦™è•‰æ ‘1å¼  + é™·é˜±1å¼ 
        const gameAssets = [heroStayImg, heroWorkImg, fakeMonkeyImg, targetMonkeyStayImg, targetMonkeyRunImg, treeImg, trapImg];
        gameAssets.forEach(img => {
            img.onload = () => { 
                assetsLoaded++; 
                if(assetsLoaded === totalGameAssets) console.log("æ‰€æœ‰æ¸¸æˆèµ„æºåŠ è½½å®Œæˆ!"); 
            };
            img.onerror = (e) => {
                console.error(`å›¾ç‰‡åŠ è½½å¤±è´¥: ${img.src}`, e);
            };
        });

        // èƒŒæ™¯é…ç½®å·²ç§»è‡³ main.jsï¼ˆåªä¿ç•™ä¸­æ™¯å±‚é…ç½®ï¼‰

        // åŠ è½½èƒŒæ™¯å›¾ç‰‡ï¼ˆåªåŠ è½½ä¸­æ™¯å±±è„‰å±‚ï¼‰
        function loadBackgroundImages() {
            backgroundImages.mid = new Image();
            backgroundImages.mid.src = 'bg_m.png?v=' + Date.now();  // ä¸­æ™¯å›¾ç‰‡ï¼ˆå±±è„‰å±‚ï¼‰
            
            // æ·»åŠ åŠ è½½å®Œæˆå›è°ƒ
            backgroundImages.mid.onload = () => {
                console.log('ä¸­æ™¯å›¾ç‰‡(bg_m.png)åŠ è½½å®Œæˆ');
            };
            
            // åŠ è½½å¤±è´¥æ—¶çš„å¤„ç†
            backgroundImages.mid.onerror = (e) => {
                console.error('ä¸­æ™¯å›¾ç‰‡(bg_m.png)åŠ è½½å¤±è´¥:', e);
                console.error('è¯·ç¡®è®¤æ–‡ä»¶æ˜¯å¦å­˜åœ¨ä¸”è·¯å¾„æ­£ç¡®');
            };
        }

        // è®¾ç½®ç”»å¸ƒå°ºå¯¸ï¼ˆå›ºå®šä¸ºæ¸¸æˆé€»è¾‘å°ºå¯¸ï¼‰
        canvas.width = GAME_WIDTH;
        canvas.height = GAME_HEIGHT;

        // æ£€æµ‹æ˜¯å¦ä¸ºç§»åŠ¨è®¾å¤‡
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                        ('ontouchstart' in window) || 
                        (navigator.maxTouchPoints > 0);

        // æ£€æµ‹å±å¹•æ–¹å‘å¹¶æ˜¾ç¤º/éšè—æ¨ªå±æç¤º
        function checkOrientation() {
            if (!isMobile) return; // åªåœ¨ç§»åŠ¨è®¾å¤‡ä¸Šæ£€æµ‹
            
            const isPortrait = window.innerHeight > window.innerWidth;
            if (isPortrait) {
                landscapePrompt.classList.add('show');
            } else {
                landscapePrompt.classList.remove('show');
            }
        }

        // ç›‘å¬å±å¹•æ–¹å‘å˜åŒ–
        window.addEventListener('resize', checkOrientation);
        window.addEventListener('orientationchange', checkOrientation);
        // åˆå§‹æ£€æµ‹
        checkOrientation();

        // ç›¸æœºç³»ç»Ÿï¼ˆç”¨äºç”»é¢æ»šåŠ¨ï¼‰
        const camera = {
            x: 0,
            y: 0,
            targetX: 0,
            followSpeed: 0.1
        };

        // æ¸¸æˆä¸–ç•Œåæ ‡ï¼ˆæ— é™å»¶ä¼¸ï¼‰
        let worldX = 0; // ä¸–ç•ŒXåæ ‡

        // çŒ´å­æŒ‘è¡…ç³»ç»Ÿé…ç½®ï¼ˆå¯è‡ªå®šä¹‰è°ƒæ•´ï¼‰- ç¬¬174è¡Œ
        // åœ¨è¿™é‡Œå¯ä»¥è°ƒæ•´è¯è¯­çš„æ˜¾ç¤ºé€Ÿåº¦å’Œé—´éš”æ—¶é—´
        // âš ï¸ å¿…é¡»åœ¨ gameState ä¹‹å‰å®šä¹‰ï¼Œå› ä¸º gameState ä¼šä½¿ç”¨è¿™ä¸ªé…ç½®
        const MONKEY_TAUNT_CONFIG = {
            // å„è·ç¦»ç­‰çº§çš„æ˜¾ç¤ºæ—¶é—´ï¼ˆç§’ï¼‰- è¯è¯­æ˜¾ç¤ºå¤šä¹…åæ¶ˆå¤±
            // æ•°å€¼è¶Šå¤§ï¼Œè¯è¯­æ˜¾ç¤ºè¶Šä¹…ï¼Œå˜åŒ–è¶Šæ…¢
            displayDuration: {
                far: 4.0,        // å¾ˆè¿œï¼ˆ>800åƒç´ ï¼‰- 4ç§’ï¼Œå¯æ”¹æˆ 6.0ã€7.0 ç­‰
                medium: 4.5,     // ä¸­ç­‰ï¼ˆ400-800åƒç´ ï¼‰- 4.5ç§’
                close: 4.0,      // è¾ƒè¿‘ï¼ˆ200-400åƒç´ ï¼‰- 4ç§’
                veryClose: 3.5   // å¾ˆè¿‘ï¼ˆ<200åƒç´ ï¼‰- 3.5ç§’
            },
            
            // ç­‰å¾…æ—¶é—´ï¼ˆç§’ï¼‰- è¯è¯­æ¶ˆå¤±åç­‰å¾…å¤šä¹…å†æ˜¾ç¤ºä¸‹ä¸€å¥
            // æ•°å€¼è¶Šå¤§ï¼Œè¯è¯­é—´éš”è¶Šé•¿ï¼Œå˜åŒ–è¶Šæ…¢
            // å¯æ”¹æˆ 5.0ã€6.0ã€8.0 ç­‰
            waitDuration: 3.0
        };

        // æ¸¸æˆçŠ¶æ€
        let gameState = {
            running: false,
            gameOver: false,
            victory: false,
            score: 0,
            distance: 0,
            bananas: 0,                    // å½“å‰é¦™è•‰æ•°é‡ï¼ˆç”±å…³å¡å‘æ”¾ï¼‰
            monkeyOutOfViewTime: 0,        // çŒ´å­ç¦»å¼€è§†é‡çš„æ—¶é—´
            isWorking: false,              // æ˜¯å¦åœ¨å¹²æ´»
            workProgress: 0,                // å¹²æ´»è¿›åº¦ï¼ˆ0-1ï¼‰
            nearBananaTree: null,          // æ¥è¿‘çš„é¦™è•‰æ ‘ï¼ˆnullè¡¨ç¤ºæ²¡æœ‰ï¼‰
            currentLevel: 0,               // å½“å‰å…³å¡ç´¢å¼•
            lastLevelChangeDistance: 0,    // ä¸Šæ¬¡å…³å¡åˆ‡æ¢æ—¶çš„è·ç¦»
            levelBananasReceived: false,    // å½“å‰å…³å¡æ˜¯å¦å·²å‘æ”¾é¦™è•‰
            levelComplete: false,           // å…³å¡æ˜¯å¦å®Œæˆ
            levelCompleteTime: 0,           // å…³å¡å®Œæˆæ—¶é—´ï¼ˆç”¨äºåŠ¨ç”»ï¼‰
            nextLevelDelay: 2.5,            // è¿›å…¥ä¸‹ä¸€å…³çš„å»¶è¿Ÿæ—¶é—´ï¼ˆç§’ï¼‰
            failedLevel: null,             // å¤±è´¥æ—¶çš„å…³å¡ç´¢å¼•ï¼ˆnullè¡¨ç¤ºä»ç¬¬ä¸€å…³å¼€å§‹ï¼‰
            dynamicMonkeySpawnTimer: 0,    // åŠ¨æ€çŒ´å­ç”Ÿæˆè®¡æ—¶å™¨
            tutorialShown: {               // å¼•å¯¼æç¤ºçŠ¶æ€
                firstBananaTree: false,    // æ˜¯å¦å·²æ˜¾ç¤ºç¬¬ä¸€æ¬¡é‡åˆ°é¦™è•‰æ ‘çš„å¼•å¯¼
                preGameInstructionsShown: false  // æ˜¯å¦å·²æ˜¾ç¤ºæ¸¸æˆå¼€å§‹å‰çš„è¯´æ˜
            },
            bananaNotificationTimer: 0,    // é¦™è•‰æç¤ºæ˜¾ç¤ºè®¡æ—¶å™¨
            bananaNotificationShown: false, // æ˜¯å¦å·²æ˜¾ç¤ºé¦™è•‰æç¤º
            speedMultiplier: 1.0,          // é€Ÿåº¦å€æ•°ï¼ˆåˆå§‹ä¸º1.0ï¼‰
            baseMaxSpeed: 8,               // ç©å®¶åŸºç¡€æœ€å¤§é€Ÿåº¦ï¼ˆå­˜å‚¨åŸå§‹å€¼ï¼‰
            baseMonkeySpeed: 5,            // çŒ´å­åŸºç¡€é€Ÿåº¦ï¼ˆå­˜å‚¨åŸå§‹å€¼ï¼‰
            obstacleSequenceIndex: 0,      // éšœç¢ç‰©ç”Ÿæˆé¡ºåºç´¢å¼•
            monkeyTaunt: {                 // çŒ´å­æŒ‘è¡…çŠ¶æ€
                currentText: '',           // å½“å‰æ˜¾ç¤ºçš„æ–‡å­—
                distanceLevel: 'far',      // å½“å‰è·ç¦»ç­‰çº§
                displayTime: 0,            // å½“å‰æ°”æ³¡æ˜¾ç¤ºæ—¶é—´ï¼ˆç§’ï¼‰
                displayDuration: 2.5,      // æ°”æ³¡æ˜¾ç¤ºæŒç»­æ—¶é—´ï¼ˆç§’ï¼‰- é»˜è®¤å€¼ï¼Œä¼šè¢«åŠ¨æ€è°ƒæ•´
                waitTime: 3,               // ç­‰å¾…æ—¶é—´ï¼ˆç§’ï¼‰- æ°”æ³¡æ¶ˆå¤±åçš„ç­‰å¾…æ—¶é—´
                waitDuration: 3.0,         // ç­‰å¾…æ—¶é—´ï¼ˆç§’ï¼‰- ä½¿ç”¨é…ç½®å€¼ï¼ˆç¬¬190è¡Œå¯è°ƒæ•´ï¼‰ï¼Œåˆå§‹åŒ–ä¸º3.0
                opacity: 0,                // é€æ˜åº¦ï¼ˆç”¨äºæ·¡å…¥æ·¡å‡ºï¼‰
                floatOffset: 0,            // æµ®åŠ¨åç§»é‡
                isWaiting: false           // æ˜¯å¦åœ¨ç­‰å¾…çŠ¶æ€
            }
        };

        // ä»é…ç½®ä¸­æ›´æ–° waitDurationï¼ˆé¿å…åˆå§‹åŒ–é¡ºåºé—®é¢˜ï¼‰
        gameState.monkeyTaunt.waitDuration = MONKEY_TAUNT_CONFIG.waitDuration;

        // æ—¶é—´ç³»ç»Ÿè®¾ç½®
        const TIME_SETTINGS = {
            outOfViewTimeLimit: 1.8,       // çŒ´å­ç¦»å¼€è§†é‡çš„æ—¶é—´é™åˆ¶ï¼ˆç§’ï¼‰- ç¼©çŸ­åˆ°1.8ç§’ï¼Œå¢åŠ ç´§è¿«æ„Ÿ
            warningTime: 1.0,              // è­¦å‘Šæ—¶é—´ï¼ˆå‰©ä½™1.0ç§’æ—¶æ˜¾ç¤ºè­¦å‘Šï¼‰
            checkInterval: 0.1             // æ£€æµ‹é—´éš”ï¼ˆç§’ï¼‰
        };

        // é¦™è•‰ç³»ç»Ÿè®¾ç½®
        const BANANA_SETTINGS = {
            initialBananas: 0,             // åˆå§‹é¦™è•‰æ•°é‡ï¼ˆæ”¹ä¸º0ï¼Œç”±å…³å¡å‘æ”¾ï¼‰
            workTime: 3.0,                 // å¹²æ´»æ—¶é—´ï¼ˆç§’ï¼‰- ç¼©çŸ­åˆ°3.0ç§’
            workReward: 2,                 // å¹²æ´»è·å¾—çš„é¦™è•‰ - ä»3é™ä½åˆ°2ï¼Œå¢åŠ éš¾åº¦
            skipCost: 4,                   // è·³è¿‡æ¶ˆè€—çš„é¦™è•‰ - ä»3å¢åŠ åˆ°4ï¼Œæé«˜æˆæœ¬
            minBananas: 0,                 // æœ€å°‘é¦™è•‰æ•°é‡ï¼ˆä¸èƒ½ä¸ºè´Ÿï¼‰
            proximityDistance: 120,       // æ¥è¿‘è·ç¦» - ä»80å¢åŠ åˆ°120ï¼Œç»™ç©å®¶æ›´å¤šæ—¶é—´
            preProximityDistance: 150      // é¢„æ¥è¿‘è·ç¦» - æå‰æ˜¾ç¤ºæç¤º
        };

        // é¦™è•‰æ ‘é…ç½®å·²ç§»è‡³ main.jsï¼Œä½¿ç”¨ TREE_CONFIG

        // éšœç¢ç‰©ç”ŸæˆèŠ‚å¥æ¨¡æ¿ï¼ˆæŒ‰å…³å¡å®šä¹‰é¡ºåºï¼‰
        const OBSTACLE_RHYTHM_PATTERNS = {
            0: ['empty', 'tree', 'empty', 'tree', 'empty', 'trap', 'tree', 'empty'], // ç¬¬ä¸€å…³ï¼šå®‰å…¨ä¸ºä¸»
            1: ['trap', 'empty', 'tree', 'empty', 'trap', 'tree', 'empty', 'monkey'], // ç¬¬äºŒå…³
            2: ['trap', 'monkey', 'tree', 'trap', 'empty', 'tree', 'monkey', 'empty'], // ç¬¬ä¸‰å…³
            3: ['trap', 'monkey', 'tree', 'trap', 'monkey', 'tree', 'empty', 'trap'], // ç¬¬å››å…³
            4: ['trap', 'monkey', 'tree', 'trap', 'monkey', 'tree', 'trap', 'empty'], // ç¬¬äº”å…³
            5: ['trap', 'monkey', 'tree', 'trap', 'monkey', 'tree', 'trap', 'monkey'], // ç¬¬å…­å…³
            6: ['trap', 'monkey', 'tree', 'trap', 'monkey', 'tree', 'trap', 'monkey'], // ç¬¬ä¸ƒå…³
            7: ['trap', 'monkey', 'tree', 'trap', 'monkey', 'tree', 'trap', 'monkey']  // ç¬¬å…«å…³
        };

        // è·å–å½“å‰å…³å¡çš„èŠ‚å¥æ¨¡å¼
        function getCurrentRhythmPattern() {
            return OBSTACLE_RHYTHM_PATTERNS[gameState.currentLevel] || 
                   OBSTACLE_RHYTHM_PATTERNS[1]; // é»˜è®¤ä½¿ç”¨ç¬¬äºŒå…³æ¨¡å¼
        }

        // è·å–ä¸‹ä¸€ä¸ªåº”è¯¥ç”Ÿæˆçš„éšœç¢ç‰©ç±»å‹
        function getNextObstacleType() {
            const pattern = getCurrentRhythmPattern();
            const type = pattern[gameState.obstacleSequenceIndex % pattern.length];
            return type;
        }

        // æ¨è¿›éšœç¢ç‰©ç”Ÿæˆé¡ºåº
        function advanceObstacleSequence() {
            gameState.obstacleSequenceIndex++;
        }

        // å…³å¡ç³»ç»Ÿè®¾ç½®
        const LEVEL_SETTINGS = {
            levels: [
                {
                    name: 'å…³å¡1 - æ–°æ‰‹è®­ç»ƒ',
                    startDistance: 0,
                    endDistance: 500,
                    trapSpacing: 2500,          // å¢åŠ åˆ°2500ï¼Œé™·é˜±æ›´ç¨€ç–
                    trapProbability: 0.008,      // è¿›ä¸€æ­¥é™ä½åˆ°0.008ï¼ˆ0.8%ï¼‰
                    treeSpacing: 350,           // ä»400é™ä½åˆ°350ï¼Œå¢åŠ é¦™è•‰æ ‘å¯†åº¦
                    treeProbability: 0.95,       // æé«˜åˆ°0.95ï¼Œå‡ ä¹å¿…å‡ºé¦™è•‰æ ‘
                    monkeySpacing: 9999,        // æå¤§å€¼ï¼Œå‡ ä¹ä¸ç”Ÿæˆ
                    monkeyProbability: 0,       // å®Œå…¨ç§»é™¤
                    bananaReward: 12,           // å¢åŠ åˆ°12ï¼Œç»™æ›´å¤šåˆå§‹é¦™è•‰
                    dynamicMonkeyEnabled: false, // ç¬¬ä¸€å…³ä¸å¯ç”¨åŠ¨æ€çŒ´å­
                    dynamicMonkeySpawnInterval: 999 // å¾ˆé•¿çš„é—´éš”
                },
                {
                    name: 'å…³å¡2 - é€æ¸é€‚åº”',
                    startDistance: 500,
                    endDistance: 1000,
                    trapSpacing: 600,           // ä»400å¢åŠ åˆ°600ï¼Œé—´è·æ›´å¤§
                    trapProbability: 0.35,       // ä»0.4é™ä½åˆ°0.35
                    treeSpacing: 500,           // ä»450å¢åŠ åˆ°500
                    treeProbability: 0.75,       // ä»0.7æé«˜åˆ°0.75
                    monkeySpacing: 800,         // ä»600å¢åŠ åˆ°800ï¼Œæ™®é€šçŒ´å­æ›´å°‘
                    monkeyProbability: 0.25,     // ä»0.3é™ä½åˆ°0.25
                    bananaReward: 5,            // ä»4å¢åŠ åˆ°5
                    dynamicMonkeyEnabled: true,  // ç¬¬äºŒå…³å¼€å§‹å¯ç”¨
                    dynamicMonkeySpawnInterval: 18.0 // ä»15å¢åŠ åˆ°18
                },
                {
                    name: 'å…³å¡3 - æŒ‘æˆ˜å‡çº§',
                    startDistance: 1000,
                    endDistance: 1500,
                    trapSpacing: 350,           // ä»280å¢åŠ åˆ°350
                    trapProbability: 0.55,       // ä»0.6é™ä½åˆ°0.55
                    treeSpacing: 420,           // ä»350å¢åŠ åˆ°420
                    treeProbability: 0.8,       // ä»0.75æé«˜åˆ°0.8
                    monkeySpacing: 500,         // ä»400å¢åŠ åˆ°500
                    monkeyProbability: 0.45,     // ä»0.5é™ä½åˆ°0.45
                    bananaReward: 5,
                    dynamicMonkeyEnabled: true,
                    dynamicMonkeySpawnInterval: 10.0 // ä»8å¢åŠ åˆ°10
                },
                {
                    name: 'å…³å¡4 - æŠ€å·§è€ƒéªŒ',
                    startDistance: 1500,
                    endDistance: 2000,
                    trapSpacing: 280,           // ä»220å¢åŠ åˆ°280
                    trapProbability: 0.6,       // ä»0.65é™ä½åˆ°0.6
                    treeSpacing: 380,           // ä»320å¢åŠ åˆ°380
                    treeProbability: 0.85,      // ä»0.8æé«˜åˆ°0.85
                    monkeySpacing: 400,         // ä»350å¢åŠ åˆ°400
                    monkeyProbability: 0.55,     // ä»0.6é™ä½åˆ°0.55
                    bananaReward: 6,            // ä»5å¢åŠ åˆ°6
                    dynamicMonkeyEnabled: true,
                    dynamicMonkeySpawnInterval: 7.0 // ä»6å¢åŠ åˆ°7
                },
                {
                    name: 'å…³å¡5 - è¿›é˜¶æŒ‘æˆ˜',
                    startDistance: 2000,
                    endDistance: 2500,
                    trapSpacing: 200,
                    trapProbability: 0.7,
                    treeSpacing: 300,
                    treeProbability: 0.8,
                    monkeySpacing: 320,
                    monkeyProbability: 0.65,
                    bananaReward: 5,
                    dynamicMonkeyEnabled: true,
                    dynamicMonkeySpawnInterval: 5.0
                },
                {
                    name: 'å…³å¡6 - é€Ÿåº¦è€ƒéªŒ',
                    startDistance: 2500,
                    endDistance: 3000,
                    trapSpacing: 180,
                    trapProbability: 0.75,
                    treeSpacing: 280,
                    treeProbability: 0.85,
                    monkeySpacing: 300,
                    monkeyProbability: 0.7,
                    bananaReward: 6,
                    dynamicMonkeyEnabled: true,
                    dynamicMonkeySpawnInterval: 4.5
                },
                {
                    name: 'å…³å¡7 - æé™æŒ‘æˆ˜',
                    startDistance: 3000,
                    endDistance: 3500,
                    trapSpacing: 160,
                    trapProbability: 0.8,
                    treeSpacing: 260,
                    treeProbability: 0.9,
                    monkeySpacing: 280,
                    monkeyProbability: 0.75,
                    bananaReward: 6,
                    dynamicMonkeyEnabled: true,
                    dynamicMonkeySpawnInterval: 4.0
                },
                {
                    name: 'å…³å¡8 - ç»ˆæè€ƒéªŒ',
                    startDistance: 3500,
                    endDistance: Infinity,      // æ— é™å…³å¡
                    trapSpacing: 150,
                    trapProbability: 0.85,
                    treeSpacing: 250,
                    treeProbability: 0.95,
                    monkeySpacing: 260,
                    monkeyProbability: 0.8,
                    bananaReward: 8,
                    dynamicMonkeyEnabled: true,
                    dynamicMonkeySpawnInterval: 3.5 // éå¸¸é¢‘ç¹
                }
            ]
        };

        // è¯„çº§ç³»ç»Ÿè®¾ç½®ï¼ˆ3ä¸ªç­‰çº§ï¼‰
        const RATING_SYSTEM = {
            getRating: function(bananas) {
                if (bananas >= 10) {
                    return {
                        level: 3,
                        name: 'é‡‡è•‰å¤§å¸ˆ',
                        color: '#f1c40f',
                        bonus: 2,
                        monkeyImage: 'monkey_gold',
                        messages: [
                            'å“‡ï¼ä½ æ˜¯é‡‡è•‰ç•Œçš„ä¼ è¯´ï¼ğŸŒâœ¨<br/>çŒ´å­éƒ½è¢«ä½ çš„é¦™è•‰æ•°é‡å“åˆ°äº†ï¼',
                            'å¤ªå¼ºäº†ï¼è¿™ä¹ˆå¤šé¦™è•‰ï¼<br/>ä¸‹ä¸€å…³çš„çŒ´å­å·²ç»åœ¨ç‘Ÿç‘Ÿå‘æŠ–äº†ï¼',
                            'é‡‡è•‰å¤§å¸ˆé©¾åˆ°ï¼ğŸŒğŸ‘‘<br/>çŒ´å­ï¼šæˆ‘æœäº†ï¼Œä¸‹ä¸€å…³è§ï¼',
                            'è¿™é¦™è•‰æ•°é‡ï¼ŒçŒ´å­çœ‹äº†éƒ½è¦å–Šä½ å¤§å“¥ï¼<br/>ç»§ç»­ä½ çš„é‡‡è•‰ä¼ å¥‡å§ï¼',
                            'å®Œç¾ï¼ä½ æ˜¯çœŸæ­£çš„é‡‡è•‰ç‹è€…ï¼<br/>ä¸‹ä¸€å…³çš„çŒ´å­å·²ç»å‡†å¤‡å¥½è¢«æŠ“ä½äº†ï¼'
                        ]
                    };
                } else if (bananas >= 6) {
                    return {
                        level: 2,
                        name: 'é‡‡è•‰é«˜æ‰‹',
                        color: '#95a5a6',
                        bonus: 1,
                        monkeyImage: 'monkey_silver',
                        messages: [
                            'ä¸é”™ä¸é”™ï¼é¦™è•‰æ”¶é›†å¾—æŒºå¤šï¼ğŸŒ<br/>ä¸‹ä¸€å…³è¿˜æœ‰æ›´å¤šé¦™è•‰åœ¨ç­‰ä½ ï¼',
                            'å¹²å¾—æ¼‚äº®ï¼çŒ´å­éƒ½è¢«ä½ è¿½ç´¯äº†ï¼<br/>ç»§ç»­åŠ æ²¹ï¼Œæˆä¸ºé‡‡è•‰å¤§å¸ˆï¼',
                            'å¥½æ ·çš„ï¼è¿™äº›é¦™è•‰å¤Ÿä½ ä¸‹ä¸€å…³ç”¨åŠ é€Ÿäº†ï¼<br/>ä¸‹ä¸€å…³çš„çŒ´å­è¦å°å¿ƒäº†ï¼',
                            'é‡‡è•‰é«˜æ‰‹å°±æ˜¯ä½ ï¼ğŸŒ<br/>ä¸‹ä¸€å…³äº‰å–æ‹¿ä¸ªé‡‘ç‰Œï¼',
                            'ä¸é”™çš„è¡¨ç°ï¼çŒ´å­éƒ½å¤¸ä½ å‰å®³ï¼<br/>ä¸‹ä¸€å…³ç»§ç»­åŠªåŠ›ï¼'
                        ]
                    };
                } else {
                    return {
                        level: 1,
                        name: 'é‡‡è•‰æ–°æ‰‹',
                        color: '#cd7f32',
                        bonus: 0,
                        monkeyImage: 'monkey_bronze',
                        messages: [
                            'æˆåŠŸæŠ“ä½ï¼è™½ç„¶é¦™è•‰ä¸å¤šğŸŒ<br/>ä½†ä¸‹ä¸€å…³è¿˜æœ‰æœºä¼šå¤§å±•èº«æ‰‹ï¼',
                            'æŠ“åˆ°å°±å¥½ï¼é¦™è•‰å¯ä»¥æ…¢æ…¢æ”¶é›†ï¼<br/>ä¸‹ä¸€å…³å¤šæ‘˜ç‚¹é¦™è•‰æ ‘ï¼',
                            'æˆåŠŸï¼è™½ç„¶é¦™è•‰å°‘ï¼Œä½†æŠ“ä½äº†å°±æ˜¯èƒœåˆ©ï¼<br/>ä¸‹ä¸€å…³äº‰å–å¤šæ”¶é›†ç‚¹ï¼',
                            'ä¸é”™ï¼è‡³å°‘æŠ“ä½çŒ´å­äº†ï¼<br/>ä¸‹ä¸€å…³è®°å¾—å¤šå¹²æ´»èµšé¦™è•‰ï¼',
                            'æˆåŠŸè¿‡å…³ï¼é¦™è•‰ä¸å¤Ÿç”¨åŠ é€Ÿï¼Ÿ<br/>ä¸‹ä¸€å…³å¤šæ‘˜ç‚¹é¦™è•‰æ ‘å°±æœ‰å•¦ï¼'
                        ]
                    };
                }
            }
        };

        // å¤±è´¥è¯­æ–™åº“
        const FAILURE_MESSAGES = {
            trap: [
                'å“å‘€ï¼æ‰è¿›é™·é˜±äº†ï¼ğŸ’€<br/>çŒ´å­ï¼šå˜¿å˜¿ï¼Œè¿™æ˜¯æˆ‘è®¾çš„ï¼',
                'è¢«é™·é˜±å‘äº†ï¼çœ‹æ¥è¿™åªçŒ´å­å¾ˆç‹¡çŒ¾ï¼<br/>ä¸‹æ¬¡è®°å¾—å¤šè§‚å¯Ÿåœ°é¢ï¼',
                'é™·é˜±å¤ªéšè”½äº†ï¼çŒ´å­è‚¯å®šåœ¨å·ç¬‘ï¼<br/>ä¸è¿‡æ²¡å…³ç³»ï¼Œå†æ¥ä¸€æ¬¡ï¼',
                'æ‰è¿›é™·é˜±äº†ï¼çŒ´å­ï¼šæ²¡æƒ³åˆ°å§ï¼Ÿ<br/>ä¸‹æ¬¡è¦å°å¿ƒè¿™äº›åœˆå¥—ï¼',
                'å“å‘€ï¼é™·é˜±å¤ªç‹¡çŒ¾äº†ï¼<br/>çŒ´å­ï¼šè¿™å°±æ˜¯æˆ‘çš„é€ƒè·‘è®¡åˆ’ï¼',
                'è¢«é™·é˜±å‘äº†ï¼çŒ´å­è‚¯å®šåœ¨è¿œå¤„çœ‹ç¬‘è¯ï¼<br/>ä¸‹æ¬¡ä¸€å®šè¦å°å¿ƒï¼',
                'é™·é˜±ï¼çŒ´å­ï¼šæƒ³æŠ“æˆ‘ï¼Ÿæ²¡é‚£ä¹ˆå®¹æ˜“ï¼<br/>å†æ¥ä¸€æ¬¡ï¼Œè¿™æ¬¡è¦å°å¿ƒï¼'
            ],
            timeout: [
                'çŒ´å­è·‘å¾—å¤ªå¿«äº†ï¼â°<br/>çŒ´å­ï¼šè¿½ä¸ä¸Šæˆ‘å§ï¼Ÿå•¦å•¦å•¦~',
                'å“å‘€ï¼è®©çŒ´å­é€ƒèµ°äº†ï¼å®ƒè·‘å¾—çœŸå¿«ï¼<br/>çŒ´å­ï¼šæ‹œæ‹œäº†æ‚¨å˜ï¼',
                'çŒ´å­æ¶ˆå¤±åœ¨è§†é‡ä¸­äº†ï¼<br/>çŒ´å­ï¼šæƒ³æŠ“æˆ‘ï¼Ÿå†ç»ƒç»ƒå§ï¼',
                'è¿½ä¸¢äº†ï¼è¿™åªçŒ´å­å¤ªæœºçµäº†ï¼<br/>çŒ´å­ï¼šæˆ‘è¿˜ä¼šå›æ¥çš„ï¼',
                'çŒ´å­é€ƒèµ°äº†ï¼ä¸è¿‡ä½ å·²ç»å¾ˆåŠªåŠ›äº†ï¼<br/>çŒ´å­ï¼šä¸‹æ¬¡è§ï¼',
                'å·®ç‚¹å°±æŠ“ä½äº†ï¼çŒ´å­è·‘å¾—æ¯”å…”å­è¿˜å¿«ï¼<br/>ä¸‹æ¬¡ä¸€å®šèƒ½æˆåŠŸï¼',
                'çŒ´å­ï¼šæƒ³æŠ“æˆ‘ï¼Ÿæ²¡é‚£ä¹ˆå®¹æ˜“ï¼<br/>ä¸‹æ¬¡è®°å¾—ç”¨åŠ é€ŸæŠ€èƒ½ï¼',
                'çŒ´å­é€ƒèµ°äº†ï¼å®ƒè‚¯å®šåœ¨å˜²ç¬‘ä½ ï¼<br/>ä¸è¿‡æ²¡å…³ç³»ï¼Œå†æ¥ä¸€æ¬¡ï¼',
                'çŒ´å­è·‘å¾—å¤ªå¿«äº†ï¼<br/>çŒ´å­ï¼šæˆ‘çš„é¦™è•‰å¯ä¸æ˜¯ç™½æ‹¿çš„ï¼'
            ],
            banana_zero: [
                'é¦™è•‰ç”¨å®Œäº†ï¼ğŸŒ<br/>æ²¡æœ‰é¦™è•‰å°±æ— æ³•ç»§ç»­æ¸¸æˆï¼',
                'é¦™è•‰æ•°é‡å½’é›¶ï¼<br/>è®°å¾—å¤šæ”¶é›†é¦™è•‰ï¼Œä¸è¦æµªè´¹ï¼',
                'é¦™è•‰ä¸å¤Ÿç”¨äº†ï¼<br/>ä¸‹æ¬¡è®°å¾—å¤šæ‘˜é¦™è•‰æ ‘ï¼',
                'é¦™è•‰å€¼ä¸º0ï¼Œæ¸¸æˆç»“æŸï¼<br/>è¦åˆç†ä½¿ç”¨é¦™è•‰ï¼Œä¸è¦è¿‡åº¦æ¶ˆè€—ï¼',
                'æ²¡æœ‰é¦™è•‰äº†ï¼<br/>è®°å¾—åœ¨é¦™è•‰æ ‘å‰å¤šå¹²æ´»èµšé¦™è•‰ï¼',
                'é¦™è•‰è€—å°½ï¼<br/>ä¸‹æ¬¡è¦æ›´è°¨æ…åœ°ä½¿ç”¨é¦™è•‰ï¼'
            ],
            normal_monkey: [
                'å“å‘€ï¼æŠ“é”™çŒ´å­äº†ï¼ğŸ’<br/>æ™®é€šçŒ´å­æ²¡æœ‰é¦™è•‰ï¼Œè¦æŠ“çš„æ˜¯ç›®æ ‡çŒ´å­ï¼',
                'æŠ“é”™äº†ï¼è¿™æ˜¯æ™®é€šçŒ´å­ï¼<br/>è®°å¾—è¦æŠ“èº«ä¸Šæœ‰é¦™è•‰çš„ç›®æ ‡çŒ´å­ï¼',
                'è¿™æ˜¯æ™®é€šçŒ´å­ï¼Œä¸æ˜¯ç›®æ ‡ï¼<br/>è¦é¿å¼€æ™®é€šçŒ´å­ï¼ŒæŠ“ç›®æ ‡çŒ´å­ï¼',
                'æŠ“é”™å¯¹è±¡äº†ï¼æ™®é€šçŒ´å­æ²¡æœ‰é¦™è•‰ï¼<br/>è¦æŠ“çš„æ˜¯æ©™è‰²å¸¦é¦™è•‰çš„ç›®æ ‡çŒ´å­ï¼',
                'æ™®é€šçŒ´å­ä¸èƒ½æŠ“ï¼<br/>è¦è·³è·ƒé¿å¼€å®ƒä»¬ï¼ŒæŠ“ç›®æ ‡çŒ´å­ï¼'
            ],
            default: [
                'å·®ç‚¹å°±æŠ“ä½äº†ï¼å†æ¥ä¸€æ¬¡å§ï¼ğŸ’ª<br/>çŒ´å­ï¼šå¥½é™©å¥½é™©ï¼',
                'æ²¡å…³ç³»ï¼Œå¤±è´¥æ˜¯æˆåŠŸä¹‹æ¯ï¼<br/>çŒ´å­ï¼šè¿™æ¬¡æˆ‘èµ¢äº†ï¼',
                'è¿™æ¬¡è¿æ°”ä¸å¥½ï¼Œä¸‹æ¬¡ä¸€å®šèƒ½æŠ“ä½ï¼<br/>çŒ´å­ï¼šæƒ³æŠ“æˆ‘ï¼Ÿå†ç»ƒç»ƒï¼',
                'çŒ´å­å¤ªç‹¡çŒ¾äº†ï¼ä¸è¿‡ä½ ä¹Ÿå¾ˆå‰å®³ï¼<br/>çŒ´å­ï¼šå˜¿å˜¿ï¼Œæˆ‘èµ¢äº†ï¼',
                'ç»§ç»­åŠªåŠ›ï¼Œä½ ä¸€å®šèƒ½æŠ“ä½å®ƒçš„ï¼<br/>çŒ´å­ï¼šä¸‹æ¬¡è§ï¼',
                'å·®ç‚¹å°±æˆåŠŸäº†ï¼<br/>çŒ´å­ï¼šå¥½é™©ï¼Œå·®ç‚¹è¢«æŠ“åˆ°ï¼'
            ]
        };

        // è·å–éšæœºå¤±è´¥æ¶ˆæ¯
        function getRandomFailureMessage(reason) {
            const messages = FAILURE_MESSAGES[reason] || FAILURE_MESSAGES.default;
            return messages[Math.floor(Math.random() * messages.length)];
        }

        // å¼•å¯¼æç¤ºç³»ç»Ÿ
        const TUTORIAL = {
            // ç»˜åˆ¶å¼•å¯¼æç¤ºï¼ˆå¸¦ç®­å¤´ï¼‰
            drawTutorial: function(ctx, message, x, y, keyHint, isMobile) {
                const padding = 15;
                const fontSize = 18;
                const keyFontSize = 16;
                
                ctx.font = `${fontSize}px Arial`;
                const textMetrics = ctx.measureText(message);
                const textWidth = textMetrics.width;
                
                // è®¡ç®—æç¤ºæ¡†å°ºå¯¸
                const boxWidth = Math.max(textWidth + padding * 2, 280);
                const boxHeight = isMobile ? 110 : 90;
                const boxX = x - boxWidth / 2;
                const boxY = y - boxHeight - 30;
                
                // ç¡®ä¿æç¤ºæ¡†åœ¨å±å¹•å†…
                const adjustedX = Math.max(10, Math.min(boxX, GAME_WIDTH - boxWidth - 10));
                const adjustedY = Math.max(10, Math.min(boxY, GAME_HEIGHT - boxHeight - 10));
                
                // ç»˜åˆ¶ç®­å¤´æŒ‡å‘ç›®æ ‡
                ctx.strokeStyle = '#f1c40f';
                ctx.lineWidth = 3;
                ctx.beginPath();
                const arrowX = x;
                const arrowY = adjustedY + boxHeight;
                ctx.moveTo(arrowX, arrowY);
                ctx.lineTo(arrowX, y);
                // ç»˜åˆ¶ç®­å¤´å¤´éƒ¨
                ctx.lineTo(arrowX - 8, y - 10);
                ctx.moveTo(arrowX, y);
                ctx.lineTo(arrowX + 8, y - 10);
                ctx.stroke();
                
                // ç»˜åˆ¶æç¤ºæ¡†èƒŒæ™¯
                ctx.fillStyle = 'rgba(0, 0, 0, 0.95)';
                ctx.fillRect(adjustedX, adjustedY, boxWidth, boxHeight);
                ctx.strokeStyle = '#f1c40f';
                ctx.lineWidth = 3;
                ctx.strokeRect(adjustedX, adjustedY, boxWidth, boxHeight);
                
                // ç»˜åˆ¶æç¤ºæ–‡å­—
                ctx.fillStyle = '#fff';
                ctx.font = `bold ${fontSize}px Arial`;
                ctx.textAlign = 'center';
                
                // å¤„ç†å¤šè¡Œæ–‡æœ¬
                const lines = message.split('\n');
                lines.forEach((line, index) => {
                    ctx.fillText(line, adjustedX + boxWidth / 2, adjustedY + 30 + index * 25);
                });
                
                // ç»˜åˆ¶æŒ‰é”®æç¤º
                if (keyHint) {
                    ctx.fillStyle = '#f1c40f';
                    ctx.font = `bold ${keyFontSize}px Arial`;
                    if (isMobile) {
                        ctx.fillText(keyHint.mobile, adjustedX + boxWidth / 2, adjustedY + 70);
                    } else {
                        ctx.fillText(keyHint.pc, adjustedX + boxWidth / 2, adjustedY + 70);
                    }
                }
                
                ctx.textAlign = 'left';
            },
            
            // ç»˜åˆ¶å¼¹çª—æç¤ºï¼ˆå±…ä¸­æ˜¾ç¤ºï¼Œæ— ç®­å¤´ï¼‰
            drawPopup: function(ctx, title, message, options, isMobile) {
                const padding = 20;
                const titleFontSize = 24;
                const messageFontSize = 18;
                const optionFontSize = 16;
                
                ctx.font = `${titleFontSize}px Arial`;
                const titleWidth = ctx.measureText(title).width;
                
                ctx.font = `${messageFontSize}px Arial`;
                const messageLines = message.split('\n');
                let maxMessageWidth = 0;
                messageLines.forEach(line => {
                    const width = ctx.measureText(line).width;
                    if (width > maxMessageWidth) maxMessageWidth = width;
                });
                
                // è®¡ç®—é€‰é¡¹å®½åº¦
                let maxOptionWidth = 0;
                if (options) {
                    options.forEach(opt => {
                        const width = ctx.measureText(opt.text).width;
                        if (width > maxOptionWidth) maxOptionWidth = width;
                    });
                }
                
                const boxWidth = Math.max(titleWidth, maxMessageWidth, maxOptionWidth) + padding * 2;
                const boxHeight = 60 + messageLines.length * 25 + (options ? options.length * 30 : 0);
                const boxX = GAME_WIDTH / 2 - boxWidth / 2;
                const boxY = GAME_HEIGHT / 2 - boxHeight / 2;
                
                // ç»˜åˆ¶åŠé€æ˜èƒŒæ™¯é®ç½©
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
                
                // ç»˜åˆ¶å¼¹çª—èƒŒæ™¯
                ctx.fillStyle = 'rgba(30, 30, 30, 0.98)';
                ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
                ctx.strokeStyle = '#f1c40f';
                ctx.lineWidth = 4;
                ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);
                
                // ç»˜åˆ¶æ ‡é¢˜
                ctx.fillStyle = '#f1c40f';
                ctx.font = `bold ${titleFontSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText(title, boxX + boxWidth / 2, boxY + 35);
                
                // ç»˜åˆ¶æ¶ˆæ¯
                ctx.fillStyle = '#fff';
                ctx.font = `${messageFontSize}px Arial`;
                messageLines.forEach((line, index) => {
                    ctx.fillText(line, boxX + boxWidth / 2, boxY + 65 + index * 25);
                });
                
                // ç»˜åˆ¶é€‰é¡¹
                if (options) {
                    let optionY = boxY + 65 + messageLines.length * 25 + 10;
                    options.forEach((opt, index) => {
                        ctx.fillStyle = opt.color || '#f1c40f';
                        ctx.font = `bold ${optionFontSize}px Arial`;
                        ctx.fillText(opt.text, boxX + boxWidth / 2, optionY + index * 30);
                    });
                }
                
                ctx.textAlign = 'left';
            }
        };

        // è™šæ‹ŸæŒ‰é”®çŠ¶æ€ï¼ˆæ‰‹æœºï¼‰
        const virtualButtons = {
            right: false,
            jump: false,
            work: false,  // å¹²æ´»æŒ‰é’®
            skip: false   // è·³è¿‡æŒ‰é’®
        };

        // è™šæ‹ŸæŒ‰é”®ä½ç½®ï¼ˆåœ¨canvasåæ ‡ç³»ä¸­ï¼‰- ä¼˜åŒ–å¸ƒå±€ï¼Œé¿å…é‡å 
        // æ³¨æ„ï¼šè·³è·ƒåœ¨å·¦ä¾§ï¼Œå‰è¿›åœ¨å³ä¾§ï¼Œäº¤äº’æŒ‰é’®ç´§æŒ¨å‰è¿›é”®
        const virtualButtonPositions = {
            jump: { x: 50, y: GAME_HEIGHT - 90, width: 100, height: 80 },                       // å·¦ä¾§ï¼Œè·³è·ƒæŒ‰é’®
            work: { x: GAME_WIDTH - 370, y: GAME_HEIGHT - 90, width: 100, height: 80 },        // å¹²æ´»æŒ‰é’®ï¼Œç´§æŒ¨è·³è¿‡æŒ‰é’®
            skip: { x: GAME_WIDTH - 260, y: GAME_HEIGHT - 90, width: 100, height: 80 },        // è·³è¿‡æŒ‰é’®ï¼Œç´§æŒ¨å‰è¿›æŒ‰é’®
            right: { x: GAME_WIDTH - 150, y: GAME_HEIGHT - 90, width: 100, height: 80 }        // å³ä¾§ï¼Œå‰è¿›æŒ‰é’®
        };

        // è§¦æ‘¸è¿½è¸ª
        let activeTouches = {};

        // è®¡ç®—ç©å®¶åˆå§‹Yä½ç½®
        const PLAYER_INITIAL_Y = GAME_HEIGHT - PLAYER_CONFIG.initialYOffset;

        // ç©å®¶å¯¹è±¡ï¼ˆä½¿ç”¨é…ç½®ï¼‰
        const player = {
            x: PLAYER_CONFIG.initialX,
            y: PLAYER_INITIAL_Y,
            width: PLAYER_CONFIG.width,
            height: PLAYER_CONFIG.height,
            speedX: 0,
            speedY: 0,
            onGround: false,
            jumpPower: -15,
            gravity: 0.8,
            maxSpeed: 8,
            color: '#3498db',
            // åŠ¨ç”»ç›¸å…³å±æ€§
            animX: { current: PLAYER_CONFIG.initialX, velocity: 0 },  // Xè½´åŠ¨ç”»çŠ¶æ€
            animY: { current: PLAYER_INITIAL_Y, velocity: 0 }  // Yè½´åŠ¨ç”»çŠ¶æ€
        };

        // å¼¹æ€§åŠ¨ç”»å‡½æ•° - æ¨¡æ‹Ÿ CSS linear ç¼“åŠ¨è½¨è¿¹
        function springAnimate(current, target, velocity, stiffness = 0.15, damping = 0.75) {
            let acceleration = (target - current) * stiffness;
            velocity += acceleration;
            velocity *= damping;
            current += velocity;
            return { current, velocity };
        }

        // åŸºäºæä¾›çš„ linear ç¼“åŠ¨æ›²çº¿çš„æ’å€¼å‡½æ•°
        function easeLinearInterpolate(t) {
            // linear(0, 0.402 7.4%, 0.711 15.3%, 0.929 23.7%, 1.008 28.2%, 1.067 33%, 1.099 36.9%, 1.12 41%, 1.13 45.4%, 1.13 50.1%, 1.111 58.5%, 1.019 83.2%, 1.004 91.3%, 1)
            const keyframes = [
                [0, 0],
                [0.074, 0.402],
                [0.153, 0.711],
                [0.237, 0.929],
                [0.282, 1.008],
                [0.33, 1.067],
                [0.369, 1.099],
                [0.41, 1.12],
                [0.454, 1.13],
                [0.501, 1.13],
                [0.585, 1.111],
                [0.832, 1.019],
                [0.913, 1.004],
                [1, 1]
            ];
            
            // é™åˆ¶ t åœ¨ 0-1 èŒƒå›´å†…
            t = Math.max(0, Math.min(1, t));
            
            // æ‰¾åˆ°å¯¹åº”çš„åŒºé—´
            for (let i = 0; i < keyframes.length - 1; i++) {
                const [t1, v1] = keyframes[i];
                const [t2, v2] = keyframes[i + 1];
                if (t >= t1 && t <= t2) {
                    // çº¿æ€§æ’å€¼
                    const ratio = (t - t1) / (t2 - t1);
                    return v1 + (v2 - v1) * ratio;
                }
            }
            return t; // é»˜è®¤è¿”å›åŸå€¼
        }

        // ç›®æ ‡çŒ´å­å¯¹è±¡ï¼ˆä½¿ç”¨é…ç½®ï¼‰
        const targetMonkey = {
            x: TARGET_MONKEY_CONFIG.initialX,
            y: PLAYER_INITIAL_Y, // ä½¿ç”¨ä¸ç©å®¶ç›¸åŒçš„Yä½ç½®
            width: TARGET_MONKEY_CONFIG.width,
            height: TARGET_MONKEY_CONFIG.height,
            speedX: TARGET_MONKEY_CONFIG.baseSpeed,
            speedY: 0,
            onGround: true,

            jumpPower: TARGET_MONKEY_CONFIG.jumpPower,
            gravity: TARGET_MONKEY_CONFIG.gravity,
            color: TARGET_MONKEY_CONFIG.color,
            hasBanana: true
        };

        // é™·é˜±æ•°ç»„
        const traps = [];
        // ä½¿ç”¨é…ç½®ä¸­çš„é™·é˜±å°ºå¯¸
        const trapWidth = PLATFORM_CONFIG.trapWidth;
        const trapHeight = PLATFORM_CONFIG.trapHeight;

        // é¦™è•‰æ ‘æ•°ç»„
        const bananaTrees = [];
        let lastTreeX = 0; // æœ€åä¸€ä¸ªé¦™è•‰æ ‘çš„Xåæ ‡

        // æ™®é€šçŒ´å­æ•°ç»„ï¼ˆé˜»ç¢ï¼‰
        const normalMonkeys = [];
        let lastNormalMonkeyX = 0; // æœ€åä¸€ä¸ªæ™®é€šçŒ´å­çš„Xåæ ‡

        // æ™®é€šçŒ´å­é…ç½®å·²ç§»è‡³ main.jsï¼Œä½¿ç”¨ NORMAL_MONKEY_CONFIG

        // çŒ´å­æŒ‘è¡…è¯è¯­åº“
        const MONKEY_TAUNTS = {
            // å¾ˆè¿œï¼ˆ>800åƒç´ ï¼‰- è¶…çº¢æ¸©å˜²è®½
            far: [
                'ä½ åœ¨çˆ¬å—ï¼Ÿæˆ‘éƒ½å¿«ç¡ç€äº†ï¼ğŸ’ğŸ’¤',
                'è¿½ä¸ä¸Šå°±åˆ«è¿½äº†ï¼å›å®¶æ´—æ´—ç¡å§ï¼ğŸ˜´',
                'ä½ è¿™ä¹ˆæ…¢ï¼Œæˆ‘éƒ½è¦ç­‰çƒ¦äº†ï¼èƒ½ä¸èƒ½å¿«ç‚¹ï¼Ÿ',
                'æˆ‘éƒ½è·‘ç´¯äº†ï¼Œä½ è¿˜åœ¨åé¢ï¼èœé¸Ÿï¼',
                'ä½ çš„é€Ÿåº¦æ˜¯èœ—ç‰›å—ï¼Ÿæˆ‘ç­‰çš„èŠ±å„¿éƒ½è°¢äº†ï¼',
                'è¿™ä¹ˆè¿œéƒ½è¿½ä¸ä¸Šï¼Ÿä½ è¿˜æ˜¯æ”¾å¼ƒå§ï¼',
                'æˆ‘åœ¨å‰é¢ç­‰ä½ ï¼Œä½ æ°¸è¿œè¿½ä¸ä¸Šçš„~',
                'ä½ è¿½å¾—ä¸Šå—ï¼Ÿæ˜æ˜¾è¿½ä¸ä¸Šï¼å›å®¶å§ï¼ğŸ˜',
                'æˆ‘éƒ½è·‘è¿™ä¹ˆè¿œäº†ï¼Œä½ è¿˜è¿½ï¼Ÿåˆ«åšæ¢¦äº†ï¼',
                'ä½ è¿™ä¹ˆæ…¢ï¼Œæˆ‘éƒ½ä¸å¥½æ„æ€è·‘å¤ªå¿«äº†~',
                'è¿½ä¸ä¸Šå°±åˆ«è¿½äº†ï¼æµªè´¹æ—¶é—´ï¼',
                'æˆ‘éƒ½ç­‰å¾—ä¸è€çƒ¦äº†ï¼ä½ èƒ½ä¸èƒ½å¿«ç‚¹ï¼ŸğŸ˜¤'
            ],
            
            // ä¸­ç­‰è·ç¦»ï¼ˆ400-800åƒç´ ï¼‰- æŒ‘è¡…å‡çº§
            medium: [
                'è¿™éƒ½è¿½ä¸ä¸Šï¼Ÿèœé¸Ÿï¼ğŸ¤­',
                'å·®ä¸€ç‚¹ç‚¹å°±æŠ“åˆ°äº†ï¼å¯æƒœå°±å·®äº¿ç‚¹ç‚¹~',
                'æˆ‘è·‘å¾—æ˜¯ä¸æ˜¯å¤ªå¿«äº†ï¼Ÿæ˜¯ä½ å¤ªæ…¢äº†ï¼',
                'ä½ å†ä¸å¿«ç‚¹ï¼Œæˆ‘å¯å°±è¦æºœäº†å“¦ï¼',
                'åŠ æ²¹ï¼åªå·®ä¸€ç‚¹ç‚¹å“¦ï¼è™½ç„¶æ°¸è¿œå·®ä¸€ç‚¹ç‚¹ğŸ˜œ',
                'å“å‘€ï¼Œä½ æ€ä¹ˆè¿˜åœ¨åé¢ï¼Ÿæˆ‘éƒ½ç­‰çƒ¦äº†',
                'è¦ä¸è¦æˆ‘ç­‰ä½ ä¸€ä¸‹ï¼Ÿæƒ³å¾—ç¾ï¼',
                'è¿½å¾—æœ‰ç‚¹åƒåŠ›å§ï¼Ÿè¦ä¸è¦ä¼‘æ¯ä¸€ä¸‹ï¼ŸğŸ’ğŸ’¨'
            ],
            
            // è¾ƒè¿‘ï¼ˆ200-400åƒç´ ï¼‰- ç´§å¼ åˆºæ¿€
            close: [
                'å“‡ï¼å·®ç‚¹è¢«æŠ“åˆ°äº†ï¼å¥½é™©å¥½é™©ï¼ğŸ˜±',
                'å¥½é™©å¥½é™©ï¼ä½ å†å¿«ç‚¹è¯•è¯•ï¼Ÿè™½ç„¶è¿˜æ˜¯è¿½ä¸ä¸Š',
                'å°±å·®é‚£ä¹ˆä¸€ç‚¹ç‚¹ï¼å¯æƒœæ°¸è¿œå·®ä¸€ç‚¹ç‚¹~',
                'æˆ‘åŠ é€Ÿäº†ï¼ä½ è¿½å¾—ä¸Šå—ï¼Ÿæ˜¾ç„¶è¿½ä¸ä¸Šï¼',
                'ç´§å¼ èµ·æ¥äº†ï¼ä½†è¿™è¿˜ä¸å¤Ÿå¿«ï¼å†ç»ƒç»ƒå§',
                'ä¸é”™ä¸é”™ï¼Œä½†æˆ‘è¿˜æ˜¯æ›´å¿«ï¼æ°”ä¸æ°”ï¼Ÿ',
                'ä½ è¿½å¾—å¾ˆåŠªåŠ›ï¼Œä½†æˆ‘æ›´åŠªåŠ›é€ƒè·‘ï¼æ°”æ­»ä½ ï¼',
                'å†å¿«ä¸€ç‚¹å°±èƒ½æŠ“åˆ°æˆ‘äº†ï¼å¯æƒœè¿˜æ˜¯ä¸å¤Ÿå¿«ï¼âš¡'
            ],
            
            // å¾ˆè¿‘ï¼ˆ<200åƒç´ ï¼‰- æœ€ç»ˆæŒ‘è¡…
            veryClose: [
                'å•Šå•Šå•Šï¼å¥½è¿‘ï¼ä½†è¿˜æ˜¯æŠ“ä¸åˆ°ï¼æ°”æ­»ä½ ï¼ğŸ˜ˆ',
                'å°±å·®ä¸€ç‚¹ï¼å°±ä¸€ç‚¹ï¼å¯æƒœæ°¸è¿œå·®ä¸€ç‚¹ï¼',
                'æˆ‘å¥½å®³æ€•ï¼æ‰æ€ªï¼ä½ æŠ“ä¸åˆ°çš„ğŸ˜',
                'ä½ æŠ“ä¸åˆ°çš„ï¼æ°¸è¿œæŠ“ä¸åˆ°çš„ï¼æ”¾å¼ƒå§ï¼',
                'è¿™ä¹ˆè¿‘éƒ½æŠ“ä¸åˆ°ï¼Ÿå“ˆå“ˆï¼èœé¸Ÿï¼',
                'ç´§å¼ å—ï¼Ÿæˆ‘æ›´ç´§å¼ ï¼æ‰æ€ªï¼æˆ‘æ ¹æœ¬ä¸æ…ŒğŸ˜',
                'è¿½å¾—è¿™ä¹ˆè¿‘ï¼Œé‚£æˆ‘å¯è¦åŠ é€Ÿäº†ï¼æ‹œæ‹œï¼ğŸ’¨',
                'ä½ çš„æ‰‹æŒ‡æ˜¯ä¸æ˜¯åœ¨æŠ–ï¼Ÿå“ˆå“ˆï¼æ‰‹æŠ–äº†å§ï¼'
            ]
        };

        // å…³å¡ç³»ç»Ÿå‡½æ•°
        function getCurrentLevel(distance) {
            for (let i = 0; i < LEVEL_SETTINGS.levels.length; i++) {
                const level = LEVEL_SETTINGS.levels[i];
                if (distance >= level.startDistance && distance < level.endDistance) {
                    return i;
                }
            }
            // å¦‚æœè¶…å‡ºæ‰€æœ‰å…³å¡ï¼Œè¿”å›æœ€åä¸€ä¸ªå…³å¡
            return LEVEL_SETTINGS.levels.length - 1;
        }

        function getCurrentLevelSettings() {
            return LEVEL_SETTINGS.levels[gameState.currentLevel];
        }

        // ç®€å•çš„ä¼ªéšæœºæ•°ç”Ÿæˆå™¨ï¼ˆä½¿ç”¨ç§å­ï¼Œç¡®ä¿æ¯ä¸ªå…³å¡éšœç¢ç‰©å›ºå®šï¼‰
        function seededRandom(seed) {
            let value = seed;
            return function() {
                value = (value * 9301 + 49297) % 233280;
                return value / 233280;
            };
        }

        // é™·é˜±ç”Ÿæˆç›¸å…³
        let lastTrapX = 0; // æœ€åä¸€ä¸ªé™·é˜±çš„Xåæ ‡
        const trapGenerationDistance = 2000; // æå‰ç”Ÿæˆé™·é˜±çš„è·ç¦»

        // åˆå§‹åŒ–é™·é˜±
        function initTraps() {
            traps.length = 0;
            // ç©å®¶åœ¨100ï¼ŒçŒ´å­åœ¨500ï¼Œå®‰å…¨åŒºåŸŸ600ï¼Œæ‰€ä»¥ä»700å¼€å§‹ç”Ÿæˆé™·é˜±
            const safeZone = 600;
            const startX = 100 + safeZone; // ç©å®¶ä½ç½® + å®‰å…¨åŒºåŸŸ
            lastTrapX = startX;
            generateTraps(startX, startX + 2000); // ä»å®‰å…¨åŒºåŸŸä¹‹åå¼€å§‹ç”Ÿæˆé™·é˜±
        }

        // åŠ¨æ€ç”Ÿæˆé™·é˜±ï¼ˆç®€åŒ–ç‰ˆï¼šåŸºäºé—´è·å¾ªç¯ï¼‰
        function generateTraps(startX, endX) {
            const groundY = GROUND_Y;
            let maxGeneratedX = startX;
            const levelSettings = getCurrentLevelSettings();
            const trapSpacing = levelSettings.trapSpacing;
            const trapProbability = levelSettings.trapProbability;
            
            // åˆ¤æ–­æ˜¯å¦ä¸ºç¬¬ä¸€å…³
            const isFirstLevel = (gameState.currentLevel === 0);
            
            // ç¬¬ä¸€å…³ï¼šå‰æ®µåŒºåŸŸå®Œå…¨ä¸ç”Ÿæˆé™·é˜±
            const firstLevelSafeZone = isFirstLevel ? 250 : 0; // 250åƒç´ å®‰å…¨åŒº
            
            // ä½¿ç”¨å…³å¡ç´¢å¼•ä½œä¸ºéšæœºç§å­ï¼Œç¡®ä¿æ¯ä¸ªå…³å¡çš„éšœç¢ç‰©å›ºå®š
            const seed = gameState.currentLevel * 1000 + Math.floor(startX / 100);
            const random = seededRandom(seed);
            
            // æŒ‰é—´è·å¾ªç¯ç”Ÿæˆï¼ˆç®€åŒ–é€»è¾‘ï¼Œä¸é¦™è•‰æ ‘ã€æ™®é€šçŒ´å­ä¸€è‡´ï¼‰
            for (let x = startX; x < endX; x += trapSpacing) {
                maxGeneratedX = x;
                
                // ç¬¬ä¸€å…³å‰æ®µåŒºåŸŸè·³è¿‡
                if (isFirstLevel && (x - startX) < firstLevelSafeZone) {
                    continue;
                }
                
                // æ£€æŸ¥å½“å‰åº”è¯¥ç”Ÿæˆä»€ä¹ˆç±»å‹çš„éšœç¢ç‰©ï¼ˆæŒ‰èŠ‚å¥é¡ºåºï¼‰
                const nextObstacleType = getNextObstacleType();
                
                // åªæœ‰åº”è¯¥ç”Ÿæˆé™·é˜±æ—¶æ‰ç»§ç»­
                if (nextObstacleType !== 'trap' && nextObstacleType !== 'empty') {
                    continue; // ä¸æ˜¯é™·é˜±æˆ–ç©ºåœ°ï¼Œè·³è¿‡ï¼ˆè®©å…¶ä»–ç”Ÿæˆå‡½æ•°å¤„ç†ï¼‰
                }
                
                // å¦‚æœæ˜¯ç©ºåœ°ï¼Œæ¨è¿›é¡ºåºå¹¶è·³è¿‡
                if (nextObstacleType === 'empty') {
                    advanceObstacleSequence();
                    continue;
                }
                
                // æ£€æŸ¥æ¦‚ç‡
                if (random() > trapProbability) {
                    continue;
                }
                
                // æ£€æŸ¥æœ€å°è·ç¦»ï¼ˆæ£€æŸ¥ä¸å…¶ä»–é™·é˜±å’Œé¦™è•‰æ ‘çš„è·ç¦»ï¼‰
                let tooClose = false;
                // æ£€æŸ¥ä¸å…¶ä»–é™·é˜±çš„è·ç¦»
                for (let existingTrap of traps) {
                    if (Math.abs(existingTrap.x - x) < TRAP_MIN_DISTANCE) {
                        tooClose = true;
                        break;
                    }
                }
                // æ£€æŸ¥ä¸é¦™è•‰æ ‘çš„è·ç¦»
                if (!tooClose) {
                    for (let tree of bananaTrees) {
                        const distance = Math.abs(tree.x - x);
                        if (distance < PLATFORM_CONFIG.minDistanceFromTree) {
                            tooClose = true;
                            break;
                        }
                    }
                }
                
                // å¦‚æœè·ç¦»åˆé€‚ï¼Œç”Ÿæˆé™·é˜±
                if (!tooClose) {
                    traps.push({
                        x: x,
                        y: groundY - trapHeight,  // é™·é˜±åº•éƒ¨è´´åœ°ï¼Œè€Œä¸æ˜¯é¡¶éƒ¨è´´åœ°
                        width: trapWidth,
                        height: trapHeight,
                        color: '#e74c3c'
                    });
                    maxGeneratedX = Math.max(maxGeneratedX, x);
                    
                    // æ¨è¿›éšœç¢ç‰©ç”Ÿæˆé¡ºåº
                    advanceObstacleSequence();
                }
            }
            
            // æ›´æ–°æœ€åä¸€ä¸ªé™·é˜±ä½ç½®
            lastTrapX = Math.max(lastTrapX, maxGeneratedX);
        }
        
        // ç¡®ä¿ç©å®¶å‰æ–¹å§‹ç»ˆæœ‰éšœç¢
        function ensureTrapsAhead() {
            if (gameState.levelComplete || !gameState.running) return;
            
            const maxWorldX = Math.max(player.x, targetMonkey.x);
            // ç¬¬ä¸€å…³æ£€æŸ¥è·ç¦»æ›´è¿œï¼Œè®©ç©å®¶æœ‰æ›´å¤šç©ºé—´
            const checkDistance = gameState.currentLevel === 0 ? 1000 : 800;
            const checkStartX = maxWorldX + 400; // ä»å®‰å…¨åŒºåŸŸåå¼€å§‹æ£€æŸ¥
            const checkEndX = maxWorldX + checkDistance;
            
            // æ£€æŸ¥è¿™ä¸ªèŒƒå›´å†…æ˜¯å¦æœ‰é™·é˜±
            let hasTrapInRange = false;
            for (let trap of traps) {
                if (trap.x >= checkStartX && trap.x <= checkEndX) {
                    hasTrapInRange = true;
                    break;
                }
            }
            
            // å¦‚æœå‰æ–¹æ²¡æœ‰é™·é˜±ï¼Œå¼ºåˆ¶ç”Ÿæˆä¸€ä¸ªï¼ˆä½¿ç”¨å›ºå®šç§å­çš„éšæœºä½ç½®ï¼‰
            if (!hasTrapInRange) {
                // ä½¿ç”¨å…³å¡ç´¢å¼•ä½œä¸ºéšæœºç§å­ï¼Œç¡®ä¿æ¯ä¸ªå…³å¡å›ºå®š
                const seed = gameState.currentLevel * 3000 + Math.floor(maxWorldX / 100);
                const random = seededRandom(seed);
                // åœ¨æ£€æŸ¥èŒƒå›´å†…ä½¿ç”¨å›ºå®šç§å­çš„éšæœºç”Ÿæˆä½ç½®
                const randomOffset = 200 + random() * (checkDistance - 400); // åœ¨200åˆ°(checkDistance-200)ä¹‹é—´éšæœº
                const generateX = maxWorldX + randomOffset;
                
                // æ£€æŸ¥ä¸å·²æœ‰é™·é˜±å’Œé¦™è•‰æ ‘çš„è·ç¦»ï¼Œç¡®ä¿ä¸å°äºæœ€å°è·ç¦»
                let tooClose = false;
                // æ£€æŸ¥ä¸å…¶ä»–é™·é˜±çš„è·ç¦»
                for (let existingTrap of traps) {
                    const distance = Math.abs(existingTrap.x - generateX);
                    if (distance < TRAP_MIN_DISTANCE) {
                        tooClose = true;
                        break;
                    }
                }
                // æ£€æŸ¥ä¸é¦™è•‰æ ‘çš„è·ç¦»
                if (!tooClose) {
                    for (let tree of bananaTrees) {
                        const distance = Math.abs(tree.x - generateX);
                        if (distance < PLATFORM_CONFIG.minDistanceFromTree) {
                            tooClose = true;
                            break;
                        }
                    }
                }
                
                // åªæœ‰å½“è·ç¦»è¶³å¤Ÿè¿œæ—¶æ‰ç”Ÿæˆé™·é˜±
                if (!tooClose) {
                    traps.push({
                        x: generateX,
                        y: GROUND_Y - trapHeight,  // é™·é˜±åº•éƒ¨è´´åœ°ï¼Œè€Œä¸æ˜¯é¡¶éƒ¨è´´åœ°
                        width: trapWidth,
                        height: trapHeight,
                        color: '#e74c3c'
                    });
                    
                    lastTrapX = Math.max(lastTrapX, generateX);
                }
            }
        }

        // æ¸…ç†å±å¹•å¤–çš„é™·é˜±
        function cleanupTraps() {
            // åªä¿ç•™ç›¸æœºå‰æ–¹å’Œåæ–¹ä¸€å®šèŒƒå›´å†…çš„é™·é˜±
            const keepRange = 500;
            for (let i = traps.length - 1; i >= 0; i--) {
                if (traps[i].x < camera.x - keepRange || traps[i].x > camera.x + GAME_WIDTH + keepRange) {
                    traps.splice(i, 1);
                }
            }
        }

        // åˆå§‹åŒ–é¦™è•‰æ ‘
        function initBananaTrees() {
            bananaTrees.length = 0;
            // ç©å®¶åœ¨100ï¼ŒçŒ´å­åœ¨500ï¼Œå®‰å…¨åŒºåŸŸ600ï¼Œæ‰€ä»¥ä»700å¼€å§‹ç”Ÿæˆé¦™è•‰æ ‘
            const safeZone = 600;
            const startX = 100 + safeZone; // ç©å®¶ä½ç½® + å®‰å…¨åŒºåŸŸ
            lastTreeX = startX;
            generateBananaTrees(startX, startX + 2000); // ä»å®‰å…¨åŒºåŸŸä¹‹åå¼€å§‹ç”Ÿæˆé¦™è•‰æ ‘
        }

        // åŠ¨æ€ç”Ÿæˆé¦™è•‰æ ‘ï¼ˆä½¿ç”¨å…³å¡å‚æ•°ï¼‰
        function generateBananaTrees(startX, endX) {
            const groundY = GROUND_Y;
            let maxGeneratedX = startX;
            const levelSettings = getCurrentLevelSettings();
            
            // å¦‚æœå…³å¡æ²¡æœ‰é¦™è•‰æ ‘ï¼Œç›´æ¥è¿”å›
            if (levelSettings.treeSpacing === 0 || levelSettings.treeProbability === 0) {
                lastTreeX = Math.max(lastTreeX, endX);
                return;
            }
            
            // ä½¿ç”¨å…³å¡ç´¢å¼•ä½œä¸ºéšæœºç§å­ï¼Œç¡®ä¿æ¯ä¸ªå…³å¡çš„é¦™è•‰æ ‘å›ºå®š
            const seed = gameState.currentLevel * 2000 + Math.floor(startX / 100);
            const random = seededRandom(seed);
            
            for (let x = startX; x < endX; x += levelSettings.treeSpacing) {
                maxGeneratedX = x;
                
                // æ£€æŸ¥å½“å‰åº”è¯¥ç”Ÿæˆä»€ä¹ˆç±»å‹çš„éšœç¢ç‰©ï¼ˆæŒ‰èŠ‚å¥é¡ºåºï¼‰
                const nextObstacleType = getNextObstacleType();
                
                // åªæœ‰å½“åº”è¯¥ç”Ÿæˆé¦™è•‰æ ‘æ—¶æ‰æ£€æŸ¥ç”Ÿæˆ
                if (nextObstacleType === 'tree') {
                    // æ£€æŸ¥ç”Ÿæˆæ¦‚ç‡ï¼ˆä½¿ç”¨å›ºå®šç§å­çš„éšæœºæ•°ï¼‰
                    if (random() <= levelSettings.treeProbability) {
                        // æ ¹æ®å…³å¡è°ƒæ•´æœ€å°è·ç¦»ï¼ˆç¬¬ä¸€å…³ä½¿ç”¨æ›´å¤§çš„å€¼ï¼‰
                        const minDistance = (gameState.currentLevel === 0) 
                            ? TREE_CONFIG.minDistanceFromTrapFirstLevel 
                            : TREE_CONFIG.minDistanceFromTrap;
                        
                        // æ£€æŸ¥æ˜¯å¦ä¸é™·é˜±å¤ªè¿‘
                        let tooCloseToTrap = false;
                        for (let trap of traps) {
                            if (Math.abs(trap.x - x) < minDistance) {
                                tooCloseToTrap = true;
                                break;
                            }
                        }
                        
                        // å¦‚æœè·ç¦»åˆé€‚ï¼Œç”Ÿæˆé¦™è•‰æ ‘
                        if (!tooCloseToTrap) {
                            bananaTrees.push({
                                x: x,
                                y: groundY - TREE_CONFIG.height,
                                width: TREE_CONFIG.width,
                                height: TREE_CONFIG.height,
                                interacted: false // æ˜¯å¦å·²ç»äº¤äº’è¿‡
                            });
                            
                            // æ¨è¿›éšœç¢ç‰©ç”Ÿæˆé¡ºåº
                            advanceObstacleSequence();
                        }
                    }
                } else if (nextObstacleType === 'empty') {
                    // å¦‚æœæ˜¯ç©ºåœ°ï¼Œç›´æ¥æ¨è¿›é¡ºåºï¼Œä¸ç”Ÿæˆä»»ä½•ä¸œè¥¿
                    advanceObstacleSequence();
                }
            }
            
            // æ›´æ–°æœ€åä¸€ä¸ªé¦™è•‰æ ‘ä½ç½®
            lastTreeX = Math.max(lastTreeX, Math.max(maxGeneratedX, endX - levelSettings.treeSpacing));
        }

        // æ¸…ç†å±å¹•å¤–çš„é¦™è•‰æ ‘
        function cleanupBananaTrees() {
            const keepRange = 500;
            for (let i = bananaTrees.length - 1; i >= 0; i--) {
                if (bananaTrees[i].x < camera.x - keepRange || bananaTrees[i].x > camera.x + GAME_WIDTH + keepRange) {
                    bananaTrees.splice(i, 1);
                }
            }
        }

        // åˆå§‹åŒ–æ™®é€šçŒ´å­
        function initNormalMonkeys() {
            normalMonkeys.length = 0;
            const safeZone = 600;
            const startX = 100 + safeZone;
            lastNormalMonkeyX = startX;
            generateNormalMonkeys(startX, startX + 2000);
        }

        // ç”Ÿæˆæ™®é€šçŒ´å­ï¼ˆä½¿ç”¨å›ºå®šç§å­ï¼‰
        function generateNormalMonkeys(startX, endX) {
            const groundY = GROUND_Y;
            const levelSettings = getCurrentLevelSettings();
            
            // å¦‚æœå…³å¡æ²¡æœ‰æ™®é€šçŒ´å­è®¾ç½®ï¼Œç›´æ¥è¿”å›
            if (!levelSettings.monkeySpacing || levelSettings.monkeyProbability === 0) {
                lastNormalMonkeyX = Math.max(lastNormalMonkeyX, endX);
                return;
            }
            
            // ä½¿ç”¨å…³å¡ç´¢å¼•ä½œä¸ºéšæœºç§å­ï¼Œç¡®ä¿æ¯ä¸ªå…³å¡å›ºå®š
            const seed = gameState.currentLevel * 4000 + Math.floor(startX / 100);
            const random = seededRandom(seed);
            
            for (let x = startX; x < endX; x += levelSettings.monkeySpacing) {
                // æ£€æŸ¥å½“å‰åº”è¯¥ç”Ÿæˆä»€ä¹ˆç±»å‹çš„éšœç¢ç‰©ï¼ˆæŒ‰èŠ‚å¥é¡ºåºï¼‰
                const nextObstacleType = getNextObstacleType();
                
                // åªæœ‰åº”è¯¥ç”Ÿæˆæ™®é€šçŒ´å­æ—¶æ‰ç»§ç»­
                if (nextObstacleType !== 'monkey' && nextObstacleType !== 'empty') {
                    continue; // ä¸æ˜¯æ™®é€šçŒ´å­æˆ–ç©ºåœ°ï¼Œè·³è¿‡ï¼ˆè®©å…¶ä»–ç”Ÿæˆå‡½æ•°å¤„ç†ï¼‰
                }
                
                // å¦‚æœæ˜¯ç©ºåœ°ï¼Œæ¨è¿›é¡ºåºå¹¶è·³è¿‡
                if (nextObstacleType === 'empty') {
                    advanceObstacleSequence();
                    continue;
                }
                
                // æ£€æŸ¥ç”Ÿæˆæ¦‚ç‡ï¼ˆä½¿ç”¨å›ºå®šç§å­çš„éšæœºæ•°ï¼‰
                if (random() <= levelSettings.monkeyProbability) {
                    // æ£€æŸ¥æ˜¯å¦ä¸é™·é˜±å¤ªè¿‘
                    let tooCloseToTrap = false;
                    for (let trap of traps) {
                        if (Math.abs(trap.x - x) < NORMAL_MONKEY_CONFIG.minDistanceFromTrap) {
                            tooCloseToTrap = true;
                            break;
                        }
                    }
                    
                    // æ£€æŸ¥æ˜¯å¦ä¸é¦™è•‰æ ‘å¤ªè¿‘
                    let tooCloseToTree = false;
                    for (let tree of bananaTrees) {
                        if (Math.abs(tree.x - x) < NORMAL_MONKEY_CONFIG.minDistanceFromTree) {
                            tooCloseToTree = true;
                            break;
                        }
                    }
                    
                    // æ£€æŸ¥æ˜¯å¦ä¸ç›®æ ‡çŒ´å­å¤ªè¿‘
                    const distanceToTarget = Math.abs(targetMonkey.x - x);
                    if (distanceToTarget < 200) {
                        tooCloseToTree = true;
                    }
                    
                    // å¦‚æœè·ç¦»åˆé€‚ï¼Œç”Ÿæˆæ™®é€šçŒ´å­
                    if (!tooCloseToTrap && !tooCloseToTree) {
                        normalMonkeys.push({
                            x: x,
                            y: groundY - NORMAL_MONKEY_CONFIG.height,
                            width: NORMAL_MONKEY_CONFIG.width,
                            height: NORMAL_MONKEY_CONFIG.height,
                            speedX: NORMAL_MONKEY_CONFIG.speedX,
                            speedY: 0,
                            onGround: true,
                            color: NORMAL_MONKEY_CONFIG.color
                        });
                        
                        // æ¨è¿›éšœç¢ç‰©ç”Ÿæˆé¡ºåº
                        advanceObstacleSequence();
                    }
                }
            }
            
            // æ›´æ–°æœ€åä¸€ä¸ªæ™®é€šçŒ´å­ä½ç½®
            lastNormalMonkeyX = Math.max(lastNormalMonkeyX, endX - levelSettings.monkeySpacing);
        }

        // æ¸…ç†å±å¹•å¤–çš„æ™®é€šçŒ´å­
        function cleanupNormalMonkeys() {
            const keepRange = 500;
            for (let i = normalMonkeys.length - 1; i >= 0; i--) {
                if (normalMonkeys[i].x < camera.x - keepRange || 
                    normalMonkeys[i].x > camera.x + GAME_WIDTH + keepRange) {
                    normalMonkeys.splice(i, 1);
                }
            }
        }

        // åŠ¨æ€ç”Ÿæˆæ™®é€šçŒ´å­ï¼ˆçªç„¶å‡ºç°ï¼‰
        function spawnDynamicNormalMonkey() {
            const levelSettings = getCurrentLevelSettings();
            
            // å¦‚æœå½“å‰å…³å¡æœªå¯ç”¨åŠ¨æ€çŒ´å­ï¼Œç›´æ¥è¿”å›
            if (!levelSettings.dynamicMonkeyEnabled) {
                return;
            }
            
            // åœ¨ç©å®¶å‰æ–¹ä¸€å®šè·ç¦»ç”Ÿæˆï¼ˆåœ¨è§†é‡å‰æ–¹ä½†ä¸åœ¨å±å¹•å†…ï¼‰
            const spawnDistance = 400; // åœ¨ç©å®¶å‰æ–¹400åƒç´ 
            const spawnX = Math.max(player.x, targetMonkey.x) + spawnDistance;
            const groundY = GROUND_Y;
            
            // æ£€æŸ¥ç”Ÿæˆä½ç½®æ˜¯å¦åˆé€‚
            let canSpawn = true;
            
            // æ£€æŸ¥æ˜¯å¦ä¸é™·é˜±å¤ªè¿‘
            for (let trap of traps) {
                if (Math.abs(trap.x - spawnX) < NORMAL_MONKEY_CONFIG.minDistanceFromTrap) {
                    canSpawn = false;
                    break;
                }
            }
            
            // æ£€æŸ¥æ˜¯å¦ä¸é¦™è•‰æ ‘å¤ªè¿‘
            if (canSpawn) {
                for (let tree of bananaTrees) {
                    if (Math.abs(tree.x - spawnX) < NORMAL_MONKEY_CONFIG.minDistanceFromTree) {
                        canSpawn = false;
                        break;
                    }
                }
            }
            
            // æ£€æŸ¥æ˜¯å¦ä¸ç›®æ ‡çŒ´å­å¤ªè¿‘
            if (canSpawn) {
                const distanceToTarget = Math.abs(targetMonkey.x - spawnX);
                if (distanceToTarget < 200) {
                    canSpawn = false;
                }
            }
            
            // æ£€æŸ¥æ˜¯å¦ä¸å…¶ä»–æ™®é€šçŒ´å­å¤ªè¿‘
            if (canSpawn) {
                for (let monkey of normalMonkeys) {
                    if (Math.abs(monkey.x - spawnX) < 150) {
                        canSpawn = false;
                        break;
                    }
                }
            }
            
            // å¦‚æœä½ç½®åˆé€‚ï¼Œç”ŸæˆåŠ¨æ€çŒ´å­
            if (canSpawn) {
                normalMonkeys.push({
                    x: spawnX,
                    y: groundY - NORMAL_MONKEY_CONFIG.height,
                    width: NORMAL_MONKEY_CONFIG.width,
                    height: NORMAL_MONKEY_CONFIG.height,
                    speedX: NORMAL_MONKEY_CONFIG.speedX,
                    speedY: 0,
                    onGround: true,
                    color: NORMAL_MONKEY_CONFIG.color,
                    isDynamic: true,  // æ ‡è®°ä¸ºåŠ¨æ€ç”Ÿæˆçš„çŒ´å­
                    spawnTime: Date.now()  // è®°å½•ç”Ÿæˆæ—¶é—´ï¼ˆå¯ç”¨äºåŠ¨ç”»æ•ˆæœï¼‰
                });
                
                console.log(`åŠ¨æ€ç”Ÿæˆæ™®é€šçŒ´å­åœ¨ä½ç½®: ${spawnX}`);
            }
        }

        // æ£€æŸ¥ç©å®¶æ˜¯å¦ç¢°åˆ°æ™®é€šçŒ´å­
        function checkNormalMonkeyCollision() {
            for (let monkey of normalMonkeys) {
                if (checkCollision(player, monkey)) {
                    return true;
                }
            }
            return false;
        }

        // é”®ç›˜æ§åˆ¶ï¼ˆç”µè„‘ï¼‰
        const keys = {};
        window.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if (e.code === 'KeyW') {
                e.preventDefault();
                if (player.onGround && gameState.running && !gameState.isWorking) {
                    player.speedY = player.jumpPower;
                    player.onGround = false;
                }
            }
            // Eé”®ä¸é¦™è•‰æ ‘äº¤äº’ï¼ˆå¹²æ´»ï¼‰
            if (e.code === 'KeyE') {
                e.preventDefault();
                if (gameState.running && gameState.nearBananaTree && !gameState.isWorking) {
                    interactWithBananaTree(gameState.nearBananaTree, 'work');
                }
            }
            // Qé”®è·³è¿‡é¦™è•‰æ ‘
            if (e.code === 'KeyQ') {
                e.preventDefault();
                if (gameState.running && gameState.nearBananaTree && !gameState.isWorking) {
                    interactWithBananaTree(gameState.nearBananaTree, 'skip');
                }
            }
        });

        window.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });

        // è§¦æ‘¸æ§åˆ¶ï¼ˆæ‰‹æœºï¼‰
        function getCanvasCoordinates(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return {
                x: (e.clientX || (e.touches && e.touches[0].clientX)) - rect.left,
                y: (e.clientY || (e.touches && e.touches[0].clientY)) - rect.top,
                scaleX: scaleX,
                scaleY: scaleY
            };
        }

        function checkVirtualButtonTouch(x, y, scaleX, scaleY) {
            const canvasX = x * scaleX;
            const canvasY = y * scaleY;

            // æ£€æŸ¥è·³è·ƒæŒ‰é’®ï¼ˆå·¦ä¾§ï¼‰
            const jumpBtn = virtualButtonPositions.jump;
            if (canvasX >= jumpBtn.x && canvasX <= jumpBtn.x + jumpBtn.width &&
                canvasY >= jumpBtn.y && canvasY <= jumpBtn.y + jumpBtn.height) {
                return 'jump';
            }

            // æ£€æŸ¥å¹²æ´»æŒ‰é’®ï¼ˆå¦‚æœæ¥è¿‘é¦™è•‰æ ‘ï¼‰
            if (gameState.nearBananaTree && !gameState.isWorking && !gameState.nearBananaTree.interacted) {
                const workBtn = virtualButtonPositions.work;
                if (canvasX >= workBtn.x && canvasX <= workBtn.x + workBtn.width &&
                    canvasY >= workBtn.y && canvasY <= workBtn.y + workBtn.height) {
                    return 'work';
                }
                
                // æ£€æŸ¥è·³è¿‡æŒ‰é’®
                const skipBtn = virtualButtonPositions.skip;
                if (canvasX >= skipBtn.x && canvasX <= skipBtn.x + skipBtn.width &&
                    canvasY >= skipBtn.y && canvasY <= skipBtn.y + skipBtn.height) {
                    // æ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿçš„é¦™è•‰
                    if (gameState.bananas >= BANANA_SETTINGS.skipCost) {
                        return 'skip';
                    }
                }
            }

            // æ£€æŸ¥å‰è¿›æŒ‰é’®ï¼ˆå³ä¾§ï¼‰
            const rightBtn = virtualButtonPositions.right;
            if (canvasX >= rightBtn.x && canvasX <= rightBtn.x + rightBtn.width &&
                canvasY >= rightBtn.y && canvasY <= rightBtn.y + rightBtn.height) {
                return 'right';
            }

            return null;
        }

        // æ£€æŸ¥è§¦æ‘¸ä½ç½®æ˜¯å¦åœ¨é¦™è•‰æ ‘ä¸Šï¼ˆç§»åŠ¨ç«¯ç›´æ¥è§¦æ‘¸äº¤äº’ï¼‰
        function checkBananaTreeTouch(canvasX, canvasY) {
            if (!gameState.running) return null;
            
            for (let tree of bananaTrees) {
                // å°†ä¸–ç•Œåæ ‡è½¬æ¢ä¸ºå±å¹•åæ ‡
                const screenX = tree.x - camera.x;
                const screenY = tree.y;
                
                // æ£€æŸ¥è§¦æ‘¸ç‚¹æ˜¯å¦åœ¨é¦™è•‰æ ‘èŒƒå›´å†…ï¼ˆæ‰©å¤§è§¦æ‘¸åŒºåŸŸï¼Œæ›´å®¹æ˜“ç‚¹å‡»ï¼‰
                const touchMargin = 20; // è§¦æ‘¸è¾¹è·ï¼Œè®©ç‚¹å‡»æ›´å®¹æ˜“
                if (canvasX >= screenX - touchMargin && 
                    canvasX <= screenX + TREE_CONFIG.width + touchMargin &&
                    canvasY >= screenY - touchMargin && 
                    canvasY <= screenY + TREE_CONFIG.height + touchMargin) {
                    return tree;
                }
            }
            return null;
        }

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const coords = getCanvasCoordinates(e);
            
            // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†é‡æ–°å¼€å§‹æŒ‰é’®ï¼ˆç§»åŠ¨è®¾å¤‡ï¼‰
            if (!gameState.running || gameState.gameOver || gameState.levelComplete) {
                const touch = e.touches[0];
                const touchX = touch.clientX - canvas.getBoundingClientRect().left;
                const touchY = touch.clientY - canvas.getBoundingClientRect().top;
                const canvasX = touchX * coords.scaleX;
                const canvasY = touchY * coords.scaleY;
                
                // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†è¯´æ˜ç•Œé¢çš„å¼€å§‹æŒ‰é’®
                if (gameState.currentLevel === 0 && !gameState.tutorialShown.preGameInstructionsShown && !gameState.gameOver) {
                    const boxWidth = 450;
                    const boxHeight = 320;  // ä»250å¢åŠ åˆ°320ï¼Œä¸ç»˜åˆ¶éƒ¨åˆ†ä¿æŒä¸€è‡´
                    const boxX = GAME_WIDTH / 2 - boxWidth / 2;
                    const boxY = GAME_HEIGHT / 2 - boxHeight / 2;
                    const btnX = boxX + boxWidth / 2 - 100;
                    const btnY = boxY + boxHeight - 70;
                    const btnWidth = 200;
                    const btnHeight = 50;
                    
                    if (canvasX >= btnX && canvasX <= btnX + btnWidth && 
                        canvasY >= btnY && canvasY <= btnY + btnHeight) {
                        gameState.tutorialShown.preGameInstructionsShown = true;
                        startGame();
                        return;
                    }
                } else {
                    // æ™®é€šå¼€å§‹/é‡æ–°å¼€å§‹æŒ‰é’®
                    const btnX = GAME_WIDTH / 2 - 100;
                    const btnY = GAME_HEIGHT / 2 + 50;
                    const btnWidth = 200;
                    const btnHeight = 50;
                    
                    if (canvasX >= btnX && canvasX <= btnX + btnWidth && 
                        canvasY >= btnY && canvasY <= btnY + btnHeight) {
                        startGame();
                        return;
                    }
                }
            }
            
            for (let i = 0; i < e.touches.length; i++) {
                const touch = e.touches[i];
                const touchX = touch.clientX - canvas.getBoundingClientRect().left;
                const touchY = touch.clientY - canvas.getBoundingClientRect().top;
                
                // æ£€æŸ¥è™šæ‹ŸæŒ‰é”®
                const button = checkVirtualButtonTouch(touchX, touchY, coords.scaleX, coords.scaleY);
                if (button) {
                    activeTouches[touch.identifier] = button;
                    virtualButtons[button] = true;
                    
                    // å¤„ç†ä¸åŒæŒ‰é’®çš„ç‚¹å‡»è¡Œä¸º
                    if (button === 'jump' && player.onGround && gameState.running) {
                        // è·³è·ƒæŒ‰é’®ï¼šç«‹å³æ‰§è¡Œè·³è·ƒ
                        player.speedY = player.jumpPower;
                        player.onGround = false;
                    } else if (button === 'work' && gameState.running && gameState.nearBananaTree && !gameState.isWorking) {
                        // å¹²æ´»æŒ‰é’®ï¼šå¼€å§‹å¹²æ´»
                        interactWithBananaTree(gameState.nearBananaTree, 'work');
                    } else if (button === 'skip' && gameState.running && gameState.nearBananaTree && !gameState.isWorking) {
                        // è·³è¿‡æŒ‰é’®ï¼šè·³è¿‡é¦™è•‰æ ‘
                        if (gameState.bananas >= BANANA_SETTINGS.skipCost) {
                            interactWithBananaTree(gameState.nearBananaTree, 'skip');
                        }
                    }
                }
            }
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            for (let i = 0; i < e.changedTouches.length; i++) {
                const touch = e.changedTouches[i];
                const button = activeTouches[touch.identifier];
                if (button) {
                    virtualButtons[button] = false;
                    delete activeTouches[touch.identifier];
                }
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            // æ›´æ–°è§¦æ‘¸ä½ç½®ï¼Œæ£€æŸ¥æ˜¯å¦è¿˜åœ¨æŒ‰é’®ä¸Š
            const coords = getCanvasCoordinates(e);
            
            for (let i = 0; i < e.touches.length; i++) {
                const touch = e.touches[i];
                const touchX = touch.clientX - canvas.getBoundingClientRect().left;
                const touchY = touch.clientY - canvas.getBoundingClientRect().top;
                
                const button = checkVirtualButtonTouch(touchX, touchY, coords.scaleX, coords.scaleY);
                const oldButton = activeTouches[touch.identifier];
                
                if (oldButton && oldButton !== button) {
                    virtualButtons[oldButton] = false;
                    delete activeTouches[touch.identifier];
                }
                
                if (button) {
                    activeTouches[touch.identifier] = button;
                    virtualButtons[button] = true;
                }
            }
        });

        // é¼ æ ‡ä½ç½®ï¼ˆç”¨äºæŒ‰é’®æ‚¬åœæ•ˆæœï¼‰
        let mouseX = 0;
        let mouseY = 0;
        let isButtonHovered = false;

        // Canvasé¼ æ ‡ç§»åŠ¨äº‹ä»¶
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            mouseX = (e.clientX - rect.left) * scaleX;
            mouseY = (e.clientY - rect.top) * scaleY;

            // æ£€æŸ¥é¼ æ ‡æ˜¯å¦åœ¨æŒ‰é’®åŒºåŸŸ
            const btnX = GAME_WIDTH / 2 - 100;
            const btnY = GAME_HEIGHT / 2 + 50;
            const btnWidth = 200;
            const btnHeight = 50;

            isButtonHovered = (mouseX >= btnX && mouseX <= btnX + btnWidth && 
                              mouseY >= btnY && mouseY <= btnY + btnHeight &&
                              (!gameState.running || gameState.gameOver));
            
            // æ”¹å˜é¼ æ ‡æ ·å¼
            canvas.style.cursor = isButtonHovered ? 'pointer' : 'default';
        });

        // Canvasç‚¹å‡»äº‹ä»¶å¤„ç†ï¼ˆç”µè„‘ï¼‰
        canvas.addEventListener('click', (e) => {
            if (isMobile) return; // æ‰‹æœºä½¿ç”¨è§¦æ‘¸äº‹ä»¶
            
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;

            // å¦‚æœæ¸¸æˆç»“æŸæˆ–æœªå¼€å§‹ï¼Œç‚¹å‡»æŒ‰é’®åŒºåŸŸå¯ä»¥é‡æ–°å¼€å§‹
            if ((!gameState.running || gameState.gameOver || gameState.levelComplete)) {
                // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†è¯´æ˜ç•Œé¢çš„å¼€å§‹æŒ‰é’®
                if (gameState.currentLevel === 0 && !gameState.tutorialShown.preGameInstructionsShown && !gameState.gameOver) {
                    const boxWidth = 450;
                    const boxHeight = 320;  // ä»250å¢åŠ åˆ°320ï¼Œä¸ç»˜åˆ¶éƒ¨åˆ†ä¿æŒä¸€è‡´
                    const boxX = GAME_WIDTH / 2 - boxWidth / 2;
                    const boxY = GAME_HEIGHT / 2 - boxHeight / 2;
                    const btnX = boxX + boxWidth / 2 - 100;
                    const btnY = boxY + boxHeight - 70;
                    const btnWidth = 200;
                    const btnHeight = 50;
                    
                    if (x >= btnX && x <= btnX + btnWidth && y >= btnY && y <= btnY + btnHeight) {
                        gameState.tutorialShown.preGameInstructionsShown = true;
                        startGame();
                    }
                } else {
                    // æ™®é€šå¼€å§‹/é‡æ–°å¼€å§‹æŒ‰é’®
                    const btnX = GAME_WIDTH / 2 - 100;
                    const btnY = GAME_HEIGHT / 2 + 50;
                    const btnWidth = 200;
                    const btnHeight = 50;
                    
                    if (x >= btnX && x <= btnX + btnWidth && y >= btnY && y <= btnY + btnHeight) {
                        startGame();
                    }
                }
            }
        });

        // ç¢°æ’æ£€æµ‹
        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }

        // æ£€æŸ¥ç©å®¶æ˜¯å¦æ‰å…¥é™·é˜±
        function checkTrapCollision() {
            const playerBottom = player.y + player.height;
            const playerTop = player.y;
            const playerLeft = player.x;
            const playerRight = player.x + player.width;
            
            // ä½¿ç”¨æ›´å°çš„ç¢°æ’ç›’å®½åº¦
            const collisionBoxWidth = PLATFORM_CONFIG.collisionBoxWidth || PLATFORM_CONFIG.trapWidth;
            const collisionBoxOffset = (PLATFORM_CONFIG.trapWidth - collisionBoxWidth) / 2; // å±…ä¸­åç§»
            
            for (let trap of traps) {
                const trapTop = trap.y;
                const trapBottom = trap.y + trap.height;
                // ä½¿ç”¨ç¼©å°åçš„ç¢°æ’ç›’å®½åº¦
                const trapLeft = trap.x + collisionBoxOffset;
                const trapRight = trap.x + collisionBoxOffset + collisionBoxWidth;
                
                // æ£€æŸ¥ç©å®¶æ˜¯å¦åœ¨é™·é˜±çš„XèŒƒå›´å†…
                const horizontalOverlap = playerRight > trapLeft && playerLeft < trapRight;
                
                // æ£€æŸ¥ç©å®¶æ˜¯å¦æ¥è§¦æˆ–æ‰å…¥é™·é˜±ï¼ˆç©å®¶çš„åº•éƒ¨æ¥è§¦åˆ°é™·é˜±çš„é¡¶éƒ¨æˆ–æ›´ä¸‹æ–¹ï¼‰
                const verticalOverlap = playerBottom >= trapTop && playerTop <= trapBottom;
                
                if (horizontalOverlap && verticalOverlap) {
                    return true;
                }
            }
            return false;
        }

        // æ£€æŸ¥æ˜¯å¦è¿½ä¸ŠçŒ´å­ï¼ˆç©å®¶è¿½ä¸ŠçŒ´å­ï¼‰
        function checkVictory() {
            // è®¡ç®—ç©å®¶å’ŒçŒ´å­çš„è·ç¦»
            const horizontalDistance = Math.abs(targetMonkey.x - player.x);
            const verticalDistance = Math.abs(player.y - targetMonkey.y);
            // å½“ç©å®¶å’ŒçŒ´å­è·ç¦»å¾ˆè¿‘æ—¶ï¼ˆæ°´å¹³è·ç¦»å°äº45ï¼Œå‚ç›´è·ç¦»å°äº40ï¼‰ï¼Œç©å®¶è¿½ä¸ŠçŒ´å­ - ç¼©å°åˆ¤å®šèŒƒå›´ï¼Œå¢åŠ éš¾åº¦
            return horizontalDistance < 45 && verticalDistance < 40;
        }

        // æ£€æŸ¥çŒ´å­æ˜¯å¦åœ¨è§†é‡å†…
        function isMonkeyInView() {
            // ç¼©å°è§†é‡èŒƒå›´ï¼Œè®©ç©å®¶æ›´å®¹æ˜“å¤±å»çŒ´å­
            const viewLeft = camera.x - 100;  // ä»-200ç¼©å°åˆ°-100
            const viewRight = camera.x + GAME_WIDTH + 100;  // ä»+200ç¼©å°åˆ°+100
            return targetMonkey.x >= viewLeft && targetMonkey.x <= viewRight;
        }

        // æ›´æ–°çŒ´å­æŒ‘è¡…ç³»ç»Ÿ
        function updateMonkeyTaunt(deltaTime) {
            if (!gameState.running || gameState.gameOver) {
                gameState.monkeyTaunt.opacity = 0;
                gameState.monkeyTaunt.currentText = '';
                gameState.monkeyTaunt.isWaiting = false;
                gameState.monkeyTaunt.waitTime = 0;
                return;
            }

            const distance = Math.abs(targetMonkey.x - player.x);
            
            // ç¡®å®šè·ç¦»ç­‰çº§ï¼ˆæ‰€æœ‰è·ç¦»éƒ½æ˜¾ç¤ºè¯è¯­ï¼‰
            let newLevel = 'far';
            if (distance < 200) {
                newLevel = 'veryClose';
            } else if (distance < 400) {
                newLevel = 'close';
            } else if (distance < 800) {
                newLevel = 'medium';
            }
            // è¶…è¿‡800åƒç´ éƒ½æ˜¯'far'ç­‰çº§
            
            // æ ¹æ®è·ç¦»ç­‰çº§åŠ¨æ€è°ƒæ•´æ˜¾ç¤ºæ—¶é—´ï¼ˆä½¿ç”¨é…ç½®å¯¹è±¡ï¼‰- ç¬¬1527è¡Œ
            // æ˜¾ç¤ºæ—¶é—´å¯åœ¨ç¬¬230-242è¡Œçš„ MONKEY_TAUNT_CONFIG.displayDuration ä¸­è°ƒæ•´
            let displayDuration = MONKEY_TAUNT_CONFIG.displayDuration[newLevel] || MONKEY_TAUNT_CONFIG.displayDuration.far;
            
            // å¦‚æœç­‰çº§æ”¹å˜ï¼Œç«‹å³æ›´æ¢è¯è¯­ï¼ˆä¸ç­‰å¾…ï¼‰
            if (newLevel !== gameState.monkeyTaunt.distanceLevel) {
                gameState.monkeyTaunt.distanceLevel = newLevel;
                changeTauntText(newLevel);
                gameState.monkeyTaunt.displayTime = 0;
                gameState.monkeyTaunt.waitTime = 0;
                gameState.monkeyTaunt.isWaiting = false;
                gameState.monkeyTaunt.opacity = 0; // é‡ç½®é€æ˜åº¦ï¼Œå‡†å¤‡æ·¡å…¥
            }
            
            // å¦‚æœåœ¨ç­‰å¾…çŠ¶æ€
            if (gameState.monkeyTaunt.isWaiting) {
                gameState.monkeyTaunt.waitTime += deltaTime;
                
                // ç­‰å¾…æ—¶é—´ç»“æŸåï¼Œæ˜¾ç¤ºæ–°è¯è¯­
                if (gameState.monkeyTaunt.waitTime >= gameState.monkeyTaunt.waitDuration) {
                    changeTauntText(newLevel);
                    gameState.monkeyTaunt.displayTime = 0;
                    gameState.monkeyTaunt.waitTime = 0;
                    gameState.monkeyTaunt.isWaiting = false;
                    gameState.monkeyTaunt.opacity = 0; // å‡†å¤‡æ·¡å…¥
                }
                return; // ç­‰å¾…æœŸé—´ä¸æ›´æ–°æ˜¾ç¤º
            }
            
            // å¦‚æœå½“å‰æ²¡æœ‰æ–‡å­—ï¼ˆæ¸¸æˆåˆšå¼€å§‹ï¼‰ï¼Œç«‹å³æ˜¾ç¤ºæ–°è¯è¯­
            if (!gameState.monkeyTaunt.currentText) {
                changeTauntText(newLevel);
                gameState.monkeyTaunt.displayTime = 0;
                gameState.monkeyTaunt.waitTime = 0;
                gameState.monkeyTaunt.isWaiting = false;
                gameState.monkeyTaunt.opacity = 0; // é‡ç½®é€æ˜åº¦ï¼Œå‡†å¤‡æ·¡å…¥
            }
            
            // æ›´æ–°æ˜¾ç¤ºæ—¶é—´
            if (gameState.monkeyTaunt.currentText) {
                gameState.monkeyTaunt.displayTime += deltaTime;
                
                // æ·¡å…¥æ·¡å‡ºåŠ¨ç”»ï¼ˆå‰0.3ç§’æ·¡å…¥ï¼Œæ˜¾ç¤ºæœŸé—´ä¿æŒä¸é€æ˜ï¼Œæœ€å0.3ç§’æ·¡å‡ºï¼‰
                const fadeInTime = 0.3;
                const fadeOutTime = 0.3;
                
                if (gameState.monkeyTaunt.displayTime < fadeInTime) {
                    // æ·¡å…¥é˜¶æ®µ
                    gameState.monkeyTaunt.opacity = Math.min(1, gameState.monkeyTaunt.displayTime / fadeInTime);
                } else if (gameState.monkeyTaunt.displayTime < displayDuration - fadeOutTime) {
                    // å®Œå…¨æ˜¾ç¤ºé˜¶æ®µ
                    gameState.monkeyTaunt.opacity = 1;
                } else if (gameState.monkeyTaunt.displayTime < displayDuration) {
                    // æ·¡å‡ºé˜¶æ®µ
                    const fadeOutProgress = (gameState.monkeyTaunt.displayTime - (displayDuration - fadeOutTime)) / fadeOutTime;
                    gameState.monkeyTaunt.opacity = Math.max(0, 1 - fadeOutProgress);
                } else {
                    // æ˜¾ç¤ºæ—¶é—´ç»“æŸï¼Œæ¸…ç©ºæ–‡å­—ï¼Œè¿›å…¥ç­‰å¾…çŠ¶æ€
                    gameState.monkeyTaunt.currentText = '';
                    gameState.monkeyTaunt.opacity = 0;
                    gameState.monkeyTaunt.displayTime = 0;
                    gameState.monkeyTaunt.waitTime = 0;
                    gameState.monkeyTaunt.isWaiting = true; // è¿›å…¥ç­‰å¾…çŠ¶æ€
                }
            }
            
            // æµ®åŠ¨åŠ¨ç”»ï¼ˆè½»å¾®ä¸Šä¸‹ç§»åŠ¨ï¼Œåªåœ¨æ˜¾ç¤ºæ—¶æµ®åŠ¨ï¼‰
            if (gameState.monkeyTaunt.opacity > 0) {
                gameState.monkeyTaunt.floatOffset = Math.sin(gameState.monkeyTaunt.displayTime * 3) * 3;
            } else {
                gameState.monkeyTaunt.floatOffset = 0;
            }
        }

        // æ›´æ¢æŒ‘è¡…è¯è¯­
        function changeTauntText(level) {
            const taunts = MONKEY_TAUNTS[level];
            if (taunts && taunts.length > 0) {
                const randomIndex = Math.floor(Math.random() * taunts.length);
                gameState.monkeyTaunt.currentText = taunts[randomIndex];
            }
        }

        // æ£€æŸ¥ç©å®¶æ˜¯å¦æ¥è¿‘é¦™è•‰æ ‘
        function checkBananaTreeProximity() {
            gameState.nearBananaTree = null;
            gameState.preNearBananaTree = null; // é¢„æ¥è¿‘çŠ¶æ€
            
            // ä½¿ç”¨æ›´å°çš„ç¢°æ’ç›’å®½åº¦
            const collisionBoxWidth = TREE_CONFIG.collisionBoxWidth || TREE_CONFIG.width;
            const collisionBoxOffset = (TREE_CONFIG.width - collisionBoxWidth) / 2; // å±…ä¸­åç§»
            
            for (let tree of bananaTrees) {
                if (tree.interacted) continue; // å·²ç»äº¤äº’è¿‡çš„æ ‘è·³è¿‡
                
                // ä½¿ç”¨ç¼©å°åçš„ç¢°æ’ç›’ä¸­å¿ƒç‚¹
                const treeCenterX = tree.x + collisionBoxOffset + collisionBoxWidth / 2;
                const playerCenterX = player.x + player.width / 2;
                const distance = Math.abs(treeCenterX - playerCenterX);
                
                // æ£€æŸ¥æ˜¯å¦åœ¨äº¤äº’è·ç¦»å†…
                if (distance < BANANA_SETTINGS.proximityDistance) {
                    gameState.nearBananaTree = tree;
                    return;
                }
                // æ£€æŸ¥æ˜¯å¦åœ¨é¢„æ¥è¿‘è·ç¦»å†…ï¼ˆæå‰æ˜¾ç¤ºæç¤ºï¼‰
                else if (distance < BANANA_SETTINGS.preProximityDistance && !gameState.nearBananaTree) {
                    gameState.preNearBananaTree = tree;
                }
            }
        }

        // ä¸é¦™è•‰æ ‘äº¤äº’
        function interactWithBananaTree(tree, action) {
            if (tree.interacted) return; // å·²ç»äº¤äº’è¿‡
            
            // æ ‡è®°ç¬¬ä¸€æ¬¡é¦™è•‰æ ‘å¼•å¯¼å·²å®Œæˆ
            if (!gameState.tutorialShown.firstBananaTree) {
                gameState.tutorialShown.firstBananaTree = true;
            }
            
            if (action === 'work') {
                // å¹²æ´»
                gameState.isWorking = true;
                gameState.workProgress = 0;
                tree.interacted = true;
            } else if (action === 'skip') {
                // è·³è¿‡
                if (gameState.bananas >= BANANA_SETTINGS.skipCost) {
                    gameState.bananas -= BANANA_SETTINGS.skipCost;
                    tree.interacted = true;
                }
            }
        }


        // æ›´æ–°æ¸¸æˆé€»è¾‘
        let lastUpdateTime = 0;
        function update() {
            // å¤„ç†å…³å¡å®Œæˆåçš„è‡ªåŠ¨è¿›å…¥ä¸‹ä¸€å…³ï¼ˆéœ€è¦åœ¨æ¸¸æˆé€»è¾‘æ›´æ–°ä¹‹å‰æ£€æŸ¥ï¼‰
            if (gameState.levelComplete && gameState.running === false) {
                const elapsed = (Date.now() - gameState.levelCompleteTime) / 1000;
                if (elapsed >= gameState.nextLevelDelay) {
                    // è‡ªåŠ¨è¿›å…¥ä¸‹ä¸€å…³
                    proceedToNextLevel();
                }
            }
            
            if (!gameState.running || gameState.gameOver) {
                return;
            }

            // è®¡ç®—deltaTimeï¼ˆç§’ï¼‰
            const currentTime = Date.now();
            const deltaTime = lastUpdateTime > 0 ? (currentTime - lastUpdateTime) / 1000 : 0.016; // é»˜è®¤16ms
            lastUpdateTime = currentTime;
            
            // æ£€æŸ¥å¼•å¯¼çŠ¶æ€ï¼ˆç®€åŒ–ç‰ˆï¼Œåªè·Ÿè¸ªé¦™è•‰æ ‘å¼•å¯¼ï¼‰
            if (!gameState.tutorialShown.firstBananaTree && 
                gameState.nearBananaTree && 
                !gameState.nearBananaTree.interacted) {
                // æ ‡è®°ç¬¬ä¸€æ¬¡é‡åˆ°é¦™è•‰æ ‘ï¼ˆç”¨äºæ˜¾ç¤ºè½»é‡çº§æç¤ºï¼‰
                gameState.tutorialShown.firstBananaTree = true;
            }

            // ç©å®¶ç§»åŠ¨ï¼ˆç”µè„‘ï¼šDé”®ï¼Œæ‰‹æœºï¼šè™šæ‹ŸæŒ‰é”®ï¼‰
            // å¹²æ´»æ—¶ä¸èƒ½ç§»åŠ¨
            if (gameState.isWorking) {
                player.speedX = 0;
                // æ›´æ–°å¹²æ´»è¿›åº¦
                gameState.workProgress += deltaTime / BANANA_SETTINGS.workTime;
                if (gameState.workProgress >= 1.0) {
                    // å¹²æ´»å®Œæˆ
                    gameState.isWorking = false;
                    gameState.workProgress = 0;
                    gameState.bananas += BANANA_SETTINGS.workReward;
                }
            } else {
                if (keys['KeyD'] || virtualButtons.right) {
                    player.speedX = player.maxSpeed;
                } else {
                    player.speedX *= 0.8; // æ‘©æ“¦åŠ›
                }
            }

            // é‡åŠ›
            player.speedY += player.gravity;
            player.y += player.speedY;

            // åœ°é¢ç¢°æ’
            const groundY = GROUND_Y;
            if (player.y + player.height >= groundY) {
                player.y = groundY - player.height;
                player.speedY = 0;
                player.onGround = true;
            } else {
                player.onGround = false;
            }

            // æ›´æ–°åŠ¨ç”»ä½ç½®ï¼ˆä½¿ç”¨å¼¹æ€§åŠ¨ç”»ï¼‰
            // ç¡®ä¿åŠ¨ç”»ä½ç½®å·²åˆå§‹åŒ–
            if (player.animX.current === undefined) {
                player.animX.current = player.x;
                player.animX.velocity = 0;
            }
            if (player.animY.current === undefined) {
                player.animY.current = player.y;
                player.animY.velocity = 0;
            }
            
            // Xè½´åŠ¨ç”»ï¼šå¹³æ»‘è·Ÿéšå®é™…ä½ç½®
            player.animX = springAnimate(
                player.animX.current, 
                player.x, 
                player.animX.velocity,
                0.2,  // stiffness - ç¨å¾®é™ä½è®©åŠ¨ç”»æ›´å¹³æ»‘
                0.85  // damping - ç¨å¾®å¢åŠ è®©åŠ¨ç”»æ›´ç¨³å®š
            );
            
            // Yè½´åŠ¨ç”»ï¼šå¹³æ»‘è·Ÿéšå®é™…ä½ç½®ï¼Œè·³è·ƒæ—¶ä½¿ç”¨ç¼“åŠ¨
            if (!player.onGround) {
                // è·³è·ƒæ—¶ï¼šä½¿ç”¨æ›´å¿«çš„å“åº”
                player.animY = springAnimate(
                    player.animY.current, 
                    player.y, 
                    player.animY.velocity,
                    0.3,  // è·³è·ƒæ—¶æ›´å¿«çš„å“åº”
                    0.8   // è·³è·ƒæ—¶æ›´å°‘çš„é˜»å°¼
                );
            } else {
                // åœ¨åœ°é¢æ—¶ï¼šä½¿ç”¨æ ‡å‡†å¼¹æ€§
                player.animY = springAnimate(
                    player.animY.current, 
                    player.y, 
                    player.animY.velocity,
                    0.2,
                    0.85
                );
            }

            // æ›´æ–°é€Ÿåº¦å€æ•°ï¼ˆè·ç¦»æ¯å¢åŠ 100ï¼Œé€Ÿåº¦æå‡5%ï¼‰
            gameState.speedMultiplier = 1.0 + Math.floor(gameState.distance / 100) * 0.05;
            
            // é™åˆ¶æœ€å¤§é€Ÿåº¦å€æ•°ï¼ˆé˜²æ­¢é€Ÿåº¦è¿‡å¿«ï¼‰
            const MAX_SPEED_MULTIPLIER = 2.0; // æœ€å¤§2å€é€Ÿåº¦
            gameState.speedMultiplier = Math.min(gameState.speedMultiplier, MAX_SPEED_MULTIPLIER);
            
            // æ›´æ–°ç©å®¶æœ€å¤§é€Ÿåº¦
            player.maxSpeed = gameState.baseMaxSpeed * gameState.speedMultiplier;
            
            // æ›´æ–°ç©å®¶ä½ç½®ï¼ˆä¸–ç•Œåæ ‡ï¼‰
            // æ£€æŸ¥æ˜¯å¦æ¥è¿‘æœªäº¤äº’çš„é¦™è•‰æ ‘ï¼Œå¦‚æœæ˜¯åˆ™é˜»æ­¢å‰è¿›
            if (gameState.nearBananaTree && !gameState.nearBananaTree.interacted) {
                // å¦‚æœæ¥è¿‘æœªäº¤äº’çš„é¦™è•‰æ ‘ï¼Œé˜»æ­¢ç©å®¶ç»§ç»­å‰è¿›
                player.speedX = Math.min(player.speedX, 0); // ä¸å…è®¸å‘å³ç§»åŠ¨
                // å¦‚æœç©å®¶å·²ç»è¶…è¿‡é¦™è•‰æ ‘ä¸­å¿ƒï¼Œå°†å…¶æ‹‰å›ï¼ˆä½¿ç”¨ç¼©å°åçš„ç¢°æ’ç›’ï¼‰
                const collisionBoxWidth = TREE_CONFIG.collisionBoxWidth || TREE_CONFIG.width;
                const collisionBoxOffset = (TREE_CONFIG.width - collisionBoxWidth) / 2;
                const treeCenterX = gameState.nearBananaTree.x + collisionBoxOffset + collisionBoxWidth / 2;
                const playerCenterX = player.x + player.width / 2;
                if (playerCenterX > treeCenterX - 10) {
                    player.x = treeCenterX - player.width / 2 - 10;
                }
            } else {
                player.x += player.speedX;
            }
            
            // æ›´æ–°ä¸–ç•Œåæ ‡
            worldX = Math.max(worldX, player.x);

            // æ›´æ–°çŒ´å­æŒ‘è¡…ç³»ç»Ÿ
            updateMonkeyTaunt(deltaTime);
            
            // æ›´æ–°ç›®æ ‡çŒ´å­ä½ç½®
            // åº”ç”¨é‡åŠ›
            targetMonkey.speedY += targetMonkey.gravity;
            targetMonkey.y += targetMonkey.speedY;
            
            // åœ°é¢ç¢°æ’
            if (targetMonkey.y + targetMonkey.height >= groundY) {
                targetMonkey.y = groundY - targetMonkey.height;
                targetMonkey.speedY = 0;
                targetMonkey.onGround = true;
            } else {
                targetMonkey.onGround = false;
            }
            
            // æ£€æµ‹å‰æ–¹é™·é˜±å¹¶è‡ªåŠ¨è·³è·ƒ
            const monkeyFrontX = targetMonkey.x + targetMonkey.width;
            const monkeyCenterX = targetMonkey.x + targetMonkey.width / 2;
            const lookAheadDistance = 150; // æå‰æ£€æµ‹è·ç¦»
            const jumpTriggerDistance = 80; // è§¦å‘è·³è·ƒçš„è·ç¦»
            
            // åªæœ‰å½“çŒ´å­åœ¨åœ°é¢ä¸Šæ—¶æ‰æ£€æµ‹é™·é˜±
            if (targetMonkey.onGround) {
                for (let trap of traps) {
                    const trapLeft = trap.x;
                    const trapRight = trap.x + trap.width;
                    const distanceToTrap = trapLeft - monkeyFrontX;
                    
                    // æ£€æŸ¥é™·é˜±æ˜¯å¦åœ¨çŒ´å­å‰æ–¹ï¼Œä¸”è·ç¦»åˆé€‚ï¼ˆå¯ä»¥è·³è·ƒè¿‡å»ï¼‰
                    if (distanceToTrap > 0 && distanceToTrap < lookAheadDistance) {
                        // æ£€æŸ¥é™·é˜±æ˜¯å¦åœ¨åœ°é¢ä¸Šï¼ˆéœ€è¦è·³è·ƒï¼‰
                        const trapTop = trap.y;
                        const trapBottom = trap.y + trap.height;
                        
                        // å¦‚æœé™·é˜±åœ¨åœ°é¢ä¸Šï¼ˆé™·é˜±é¡¶éƒ¨åœ¨åœ°é¢æˆ–æ¥è¿‘åœ°é¢ï¼‰
                        if (trapTop <= groundY && trapBottom >= groundY - 10) {
                            // åœ¨åˆé€‚çš„è·ç¦»è§¦å‘è·³è·ƒï¼ˆæå‰ä¸€ç‚¹è·³è·ƒï¼Œç¡®ä¿èƒ½è·³è¿‡ï¼‰
                            if (distanceToTrap <= jumpTriggerDistance) {
                                targetMonkey.speedY = targetMonkey.jumpPower;
                                targetMonkey.onGround = false;
                                break; // åªå¤„ç†ç¬¬ä¸€ä¸ªé‡åˆ°çš„é™·é˜±
                            }
                        }
                    }
                }
            }
            
            // çŒ´å­ä¸€ç›´å‘å‰ç§»åŠ¨
            targetMonkey.x += targetMonkey.speedX;
            
            // å¦‚æœç©å®¶æ¥è¿‘ï¼ŒçŒ´å­ä¼šåŠ é€Ÿé€ƒè·‘ï¼ˆåº”ç”¨é€Ÿåº¦å€æ•°ï¼‰
            const currentMonkeySpeed = gameState.baseMonkeySpeed * gameState.speedMultiplier;
            if (player.x > targetMonkey.x - 300) {
                targetMonkey.speedX = currentMonkeySpeed * 1.3;  // ç©å®¶æ¥è¿‘æ—¶æ›´å¿«ï¼ˆåŸºç¡€é€Ÿåº¦ * å€æ•° * 1.3ï¼‰
            } else {
                targetMonkey.speedX = currentMonkeySpeed;  // æ­£å¸¸é€Ÿåº¦ï¼ˆåŸºç¡€é€Ÿåº¦ * å€æ•°ï¼‰
            }
            
            // ç›¸æœºè·Ÿéšï¼ˆè·Ÿéšç©å®¶å’ŒçŒ´å­çš„ä¸­é—´ä½ç½®ï¼Œä½†æ›´åå‘ç©å®¶ï¼‰
            const followTarget = (player.x + targetMonkey.x) / 2;
            camera.targetX = followTarget - GAME_WIDTH / 3; // è®©ç©å®¶ç¨å¾®åå·¦
            camera.x += (camera.targetX - camera.x) * camera.followSpeed;
            
            // ç¡®ä¿ç›¸æœºä¸ä¼šå‘åç§»åŠ¨
            camera.x = Math.max(camera.x, 0);
            
            // åŠ¨æ€ç”Ÿæˆé™·é˜±ï¼ˆæŒç»­ç”Ÿæˆï¼‰
            const maxWorldX = Math.max(player.x, targetMonkey.x);
            // ç¡®ä¿å§‹ç»ˆåœ¨å‰æ–¹ç”Ÿæˆè¶³å¤Ÿçš„é™·é˜±
            // ç¡®ä¿é™·é˜±ä¸ä¼šåœ¨ç©å®¶å½“å‰ä½ç½®é™„è¿‘ç”Ÿæˆï¼ˆå®‰å…¨åŒºåŸŸï¼‰
            const safeZone = 400; // åŠ¨æ€ç”Ÿæˆæ—¶çš„å®‰å…¨åŒºåŸŸï¼ˆå¯ä»¥æ¯”å…³å¡å¼€å§‹æ—¶çš„ç¨å°ï¼‰
            const minTrapX = maxWorldX + safeZone; // é™·é˜±ç”Ÿæˆçš„æœ€å°Xåæ ‡
            
            if (lastTrapX < maxWorldX + trapGenerationDistance) {
                const generateStartX = Math.max(lastTrapX, minTrapX); // ç¡®ä¿ä»å®‰å…¨åŒºåŸŸä¹‹åå¼€å§‹
                const generateEndX = maxWorldX + trapGenerationDistance;
                const oldLastTrapX = lastTrapX;
                generateTraps(generateStartX, generateEndX);
                // ç¡®ä¿lastTrapXè¢«æ›´æ–°ï¼ˆé˜²æ­¢æ— é™å¾ªç¯ï¼‰
                if (lastTrapX === oldLastTrapX) {
                    lastTrapX = generateEndX;
                }
            }
            
            // æ¸…ç†å±å¹•å¤–çš„é™·é˜±
            cleanupTraps();
            
            // ç¡®ä¿ç©å®¶å‰æ–¹å§‹ç»ˆæœ‰éšœç¢
            ensureTrapsAhead();

            // åŠ¨æ€ç”Ÿæˆé¦™è•‰æ ‘ï¼ˆæŒç»­ç”Ÿæˆï¼‰
            if (lastTreeX < maxWorldX + trapGenerationDistance) {
                // ç¡®ä¿é¦™è•‰æ ‘ä¸ä¼šåœ¨ç©å®¶å½“å‰ä½ç½®é™„è¿‘ç”Ÿæˆï¼ˆå®‰å…¨åŒºåŸŸï¼‰
                const safeZone = 400; // åŠ¨æ€ç”Ÿæˆæ—¶çš„å®‰å…¨åŒºåŸŸ
                const minTreeX = maxWorldX + safeZone; // é¦™è•‰æ ‘ç”Ÿæˆçš„æœ€å°Xåæ ‡
                const generateStartX = Math.max(lastTreeX, minTreeX); // ç¡®ä¿ä»å®‰å…¨åŒºåŸŸä¹‹åå¼€å§‹
                const generateEndX = maxWorldX + trapGenerationDistance;
                const oldLastTreeX = lastTreeX;
                generateBananaTrees(generateStartX, generateEndX);
                // ç¡®ä¿lastTreeXè¢«æ›´æ–°
                if (lastTreeX === oldLastTreeX) {
                    lastTreeX = generateEndX;
                }
            }
            
            // æ¸…ç†å±å¹•å¤–çš„é¦™è•‰æ ‘
            cleanupBananaTrees();

            // åŠ¨æ€ç”Ÿæˆæ™®é€šçŒ´å­ï¼ˆæŒç»­ç”Ÿæˆï¼‰
            if (lastNormalMonkeyX < maxWorldX + trapGenerationDistance) {
                // ç¡®ä¿æ™®é€šçŒ´å­ä¸ä¼šåœ¨ç©å®¶å½“å‰ä½ç½®é™„è¿‘ç”Ÿæˆï¼ˆå®‰å…¨åŒºåŸŸï¼‰
                const safeZone = 400;
                const minMonkeyX = maxWorldX + safeZone;
                const generateStartX = Math.max(lastNormalMonkeyX, minMonkeyX);
                const generateEndX = maxWorldX + trapGenerationDistance;
                const oldLastNormalMonkeyX = lastNormalMonkeyX;
                generateNormalMonkeys(generateStartX, generateEndX);
                // ç¡®ä¿lastNormalMonkeyXè¢«æ›´æ–°
                if (lastNormalMonkeyX === oldLastNormalMonkeyX) {
                    lastNormalMonkeyX = generateEndX;
                }
            }
            
            // æ¸…ç†å±å¹•å¤–çš„æ™®é€šçŒ´å­
            cleanupNormalMonkeys();

            // åŠ¨æ€ç”Ÿæˆæ™®é€šçŒ´å­ï¼ˆçªç„¶å‡ºç°ï¼‰
            if (gameState.running && !gameState.isWorking) {
                const levelSettings = getCurrentLevelSettings();
                if (levelSettings.dynamicMonkeyEnabled) {
                    // åˆå§‹åŒ–è®¡æ—¶å™¨
                    if (gameState.dynamicMonkeySpawnTimer === undefined) {
                        gameState.dynamicMonkeySpawnTimer = 0;
                    }
                    
                    gameState.dynamicMonkeySpawnTimer += deltaTime;
                    
                    // å¦‚æœè¾¾åˆ°ç”Ÿæˆé—´éš”ï¼Œå°è¯•ç”ŸæˆåŠ¨æ€çŒ´å­
                    if (gameState.dynamicMonkeySpawnTimer >= levelSettings.dynamicMonkeySpawnInterval) {
                        spawnDynamicNormalMonkey();
                        gameState.dynamicMonkeySpawnTimer = 0; // é‡ç½®è®¡æ—¶å™¨
                    }
                }
            }

            // æ£€æµ‹å…³å¡åˆ‡æ¢ï¼ˆä»…åœ¨æ¸¸æˆè¿è¡Œä¸”æœªå®Œæˆå…³å¡æ—¶ï¼‰
            if (gameState.running && !gameState.levelComplete) {
                const newLevel = getCurrentLevel(gameState.distance);
                if (newLevel !== gameState.currentLevel) {
                    const oldLevel = gameState.currentLevel;
                    gameState.currentLevel = newLevel;
                    gameState.lastLevelChangeDistance = gameState.distance;
                    gameState.levelBananasReceived = false; // é‡ç½®é¦™è•‰å‘æ”¾æ ‡å¿—
                    gameState.dynamicMonkeySpawnTimer = 0; // é‡ç½®åŠ¨æ€çŒ´å­è®¡æ—¶å™¨
                    
                    // æ¸…ç†æ—§å…³å¡çš„éšœç¢ç‰©ï¼ˆé‡æ–°ç”Ÿæˆï¼‰
                    const currentLevelSettings = LEVEL_SETTINGS.levels[newLevel];
                    const cleanupDistance = 500;
                    
                    // æ¸…ç†è¶…å‡ºèŒƒå›´çš„é™·é˜±
                    for (let i = traps.length - 1; i >= 0; i--) {
                        if (traps[i].x < gameState.distance - cleanupDistance || 
                            traps[i].x > gameState.distance + 2000) {
                            traps.splice(i, 1);
                        }
                    }
                    
                    // æ¸…ç†è¶…å‡ºèŒƒå›´çš„é¦™è•‰æ ‘
                    for (let i = bananaTrees.length - 1; i >= 0; i--) {
                        if (bananaTrees[i].x < gameState.distance - cleanupDistance || 
                            bananaTrees[i].x > gameState.distance + 2000) {
                            bananaTrees.splice(i, 1);
                        }
                    }
                    
                    // æ¸…ç†è¶…å‡ºèŒƒå›´çš„æ™®é€šçŒ´å­
                    for (let i = normalMonkeys.length - 1; i >= 0; i--) {
                        if (normalMonkeys[i].x < gameState.distance - cleanupDistance || 
                            normalMonkeys[i].x > gameState.distance + 2000) {
                            normalMonkeys.splice(i, 1);
                        }
                    }
                    
                    // é‡ç½®ç”Ÿæˆä½ç½®ï¼ˆç»™ç©å®¶ä¸€ä¸ªå®‰å…¨åŒºåŸŸï¼‰
                    // ä½¿ç”¨ç©å®¶å½“å‰ä½ç½®ï¼ˆworldXï¼‰è€Œä¸æ˜¯è·ç¦»ï¼Œå› ä¸ºè·ç¦»æ˜¯é™¤ä»¥10çš„
                    const safeZone = 600; // å®‰å…¨åŒºåŸŸï¼ˆåƒç´ ï¼‰
                    const playerCurrentX = worldX; // ç©å®¶å½“å‰ä¸–ç•Œåæ ‡
                    const generateStartX = playerCurrentX + safeZone; // ä»ç©å®¶ä½ç½®+å®‰å…¨åŒºåŸŸå¼€å§‹ç”Ÿæˆ
                    lastTrapX = generateStartX;
                    lastTreeX = generateStartX;
                    lastNormalMonkeyX = generateStartX;
                    
                    // ç«‹å³ç”Ÿæˆæ–°å…³å¡çš„éšœç¢ç‰©ï¼ˆä»å®‰å…¨åŒºåŸŸä¹‹åå¼€å§‹ï¼‰
                    const generateEndX = generateStartX + trapGenerationDistance;
                    generateTraps(generateStartX, generateEndX);
                    generateBananaTrees(generateStartX, generateEndX);
                    generateNormalMonkeys(generateStartX, generateEndX);
                    
                    console.log(`è¿›å…¥${currentLevelSettings.name}ï¼Œå‘æ”¾${currentLevelSettings.bananaReward}ä¸ªé¦™è•‰`);
                }
            }
            
            // å…³å¡å¼€å§‹æ—¶å‘æ”¾é¦™è•‰
            if (gameState.running && !gameState.levelBananasReceived) {
                const currentLevelSettings = LEVEL_SETTINGS.levels[gameState.currentLevel];
                gameState.bananas += currentLevelSettings.bananaReward;
                gameState.levelBananasReceived = true;
                gameState.bananaNotificationShown = false; // æ˜¾ç¤ºé¦™è•‰æç¤º
                gameState.bananaNotificationTimer = 0; // é‡ç½®è®¡æ—¶å™¨
                console.log(`è·å¾—${currentLevelSettings.bananaReward}ä¸ªé¦™è•‰ï¼Œå½“å‰æ€»æ•°ï¼š${gameState.bananas}`);
            }
            
            // æ›´æ–°é¦™è•‰æç¤ºè®¡æ—¶å™¨
            if (gameState.running && !gameState.bananaNotificationShown) {
                gameState.bananaNotificationTimer += deltaTime;
            }

            // æ£€æŸ¥ç©å®¶æ˜¯å¦æ¥è¿‘é¦™è•‰æ ‘
            checkBananaTreeProximity();

            // æ£€æµ‹çŒ´å­æ˜¯å¦åœ¨è§†é‡å†…
            if (isMonkeyInView()) {
                gameState.monkeyOutOfViewTime = 0; // é‡ç½®æ—¶é—´
            } else {
                gameState.monkeyOutOfViewTime += deltaTime;
                // å¦‚æœçŒ´å­ç¦»å¼€è§†é‡è¶…è¿‡é™åˆ¶æ—¶é—´ï¼Œæ¸¸æˆå¤±è´¥
                if (gameState.monkeyOutOfViewTime >= TIME_SETTINGS.outOfViewTimeLimit) {
                    gameState.gameOver = true;
                    gameState.running = false;
                    showGameOver(false, 'timeout');
                }
            }

            // æ£€æŸ¥ç¢°æ’
            if (checkTrapCollision()) {
                gameState.gameOver = true;
                gameState.running = false;
                showGameOver(false, 'trap');
            }

            // æ£€æŸ¥æ˜¯å¦ç¢°åˆ°æ™®é€šçŒ´å­ï¼ˆå¤±è´¥ï¼‰
            if (checkNormalMonkeyCollision()) {
                gameState.gameOver = true;
                gameState.running = false;
                showGameOver(false, 'normal_monkey');
            }

            // æ£€æŸ¥é¦™è•‰å€¼æ˜¯å¦ä¸º0
            if (gameState.bananas <= 0) {
                gameState.gameOver = true;
                gameState.running = false;
                showGameOver(false, 'banana_zero');
            }

            // æ£€æŸ¥èƒœåˆ©ï¼ˆç©å®¶è¿½ä¸ŠçŒ´å­ï¼‰
            if (checkVictory()) {
                // ä¸ç›´æ¥ç»“æŸæ¸¸æˆï¼Œè€Œæ˜¯å®Œæˆå½“å‰å…³å¡
                if (!gameState.levelComplete) {
                    gameState.levelComplete = true;
                    gameState.levelCompleteTime = Date.now();
                    gameState.victory = true;
                    gameState.running = false; // æš‚åœæ¸¸æˆé€»è¾‘
                    gameState.score += 1000;
                    
                    // è®¡ç®—è¯„çº§
                    const rating = RATING_SYSTEM.getRating(gameState.bananas);
                    
                    // æ˜¾ç¤ºå…³å¡å®Œæˆç•Œé¢
                    showLevelComplete(rating);
                    
                    console.log(`å…³å¡å®Œæˆï¼è¯„çº§ï¼š${rating.grade}ï¼Œé¦™è•‰æ•°ï¼š${gameState.bananas}`);
                }
            }

            // æ›´æ–°åˆ†æ•°å’Œè·ç¦»ï¼ˆä½¿ç”¨ä¸–ç•Œåæ ‡ï¼‰
            gameState.distance = Math.floor(worldX / 10);
            if (player.onGround && player.speedX !== 0) {
                gameState.score += 1;
            }
        }

        // ç»˜åˆ¶è‡ªå®šä¹‰èƒŒæ™¯ï¼ˆå¤©ç©º + åœ°é¢ï¼‰
        function drawCustomBackground(ctx, cameraX) {
            // 1. ç»˜åˆ¶å¤©ç©ºæ¸å˜ï¼ˆä½¿ç”¨é…ç½®ï¼‰
            const skyGradient = ctx.createLinearGradient(0, 0, 0, GAME_HEIGHT);
            skyGradient.addColorStop(SKY_CONFIG.gradientStop1, SKY_CONFIG.colorTop);
            skyGradient.addColorStop(SKY_CONFIG.gradientStop2, SKY_CONFIG.colorMid);
            skyGradient.addColorStop(SKY_CONFIG.gradientStop3, SKY_CONFIG.colorBottom);
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            
            // 2. ç»˜åˆ¶åœ°é¢/è‰åœ°ï¼ˆä½¿ç”¨é…ç½®ï¼‰
            const groundY = GROUND_Y;
            const grassHeight = GROUND_CONFIG.grassHeight;
            
            // è‰åœ°æ¸å˜
            const grassGradient = ctx.createLinearGradient(0, groundY - grassHeight, 0, groundY);
            grassGradient.addColorStop(0, GROUND_CONFIG.grassColorTop);
            grassGradient.addColorStop(1, GROUND_CONFIG.grassColorBottom);
            ctx.fillStyle = grassGradient;
            ctx.fillRect(0, groundY - grassHeight, GAME_WIDTH, grassHeight);
            
            // åœ°é¢ï¼ˆåœŸè‰²ï¼‰
            ctx.fillStyle = GROUND_CONFIG.groundColor;
            ctx.fillRect(0, groundY, GAME_WIDTH, GAME_HEIGHT - groundY);
            
            // 3. ç»˜åˆ¶äº‘æœµï¼ˆä½¿ç”¨é…ç½®ï¼‰
            ctx.fillStyle = CLOUD_CONFIG.color;
            const cloudOffset = (cameraX * CLOUD_CONFIG.parallaxSpeed) % (GAME_WIDTH * 2);
            for (let i = 0; i < CLOUD_CONFIG.count; i++) {
                const cloudX = (i * CLOUD_CONFIG.spacingX - cloudOffset) % (GAME_WIDTH + 200);
                const cloudY = CLOUD_CONFIG.baseY + i * CLOUD_CONFIG.spacingY;
                drawCloud(ctx, cloudX, cloudY);
            }
        }
        
        // ç»˜åˆ¶äº‘æœµçš„è¾…åŠ©å‡½æ•°ï¼ˆä½¿ç”¨é…ç½®ï¼‰
        function drawCloud(ctx, x, y) {
            ctx.beginPath();
            ctx.arc(x, y, CLOUD_CONFIG.radius1, 0, Math.PI * 2);
            ctx.arc(x + 25, y, CLOUD_CONFIG.radius2, 0, Math.PI * 2);
            ctx.arc(x + 50, y, CLOUD_CONFIG.radius3, 0, Math.PI * 2);
            ctx.fill();
        }

        // ç»˜åˆ¶æ¸¸æˆ
        function draw() {
            // æ¸…é™¤ç”»å¸ƒ
            ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            
            // ç¦ç”¨å¹³æ»‘ï¼Œä¿æŒåƒç´ ç”»è´¨ï¼ˆåƒç´ æ¸¸æˆå¿…å¤‡ï¼‰
            ctx.imageSmoothingEnabled = false;
            // å¦‚æœæµè§ˆå™¨æ”¯æŒï¼Œè®¾ç½®ä½è´¨é‡å¹³æ»‘ï¼ˆè¿›ä¸€æ­¥å‡å°‘æŠ—é”¯é½¿å’Œç™½è¾¹ï¼‰
            if (ctx.imageSmoothingQuality) {
                ctx.imageSmoothingQuality = 'low';
            }

            // ========== èƒŒæ™¯ç»˜åˆ¶ ==========
            // ç»˜åˆ¶è‡ªå®šä¹‰èƒŒæ™¯ï¼ˆå¤©ç©º + åœ°é¢ï¼‰
            drawCustomBackground(ctx, camera.x);
            
            // ç»˜åˆ¶ä¸­æ™¯å±‚ (bg_m.png) - å±±è„‰å±‚ï¼Œå¸¦è§†å·®æ•ˆæœ
            if (backgroundImages.mid && backgroundImages.mid.complete) {
                ctx.imageSmoothingEnabled = false;
                if (ctx.imageSmoothingQuality) {
                    ctx.imageSmoothingQuality = 'low';
                }
                
                ctx.save();
                ctx.globalCompositeOperation = 'source-over';
                
                const layer = BACKGROUND_CONFIG.mid;
                const layerWidth = layer.width || GAME_WIDTH;
                const layerHeight = layer.height || GAME_HEIGHT;
                const layerX = layer.x;
                const layerY = layer.y;
                
                // è®¡ç®—è§†å·®åç§»ï¼šç›¸æœºç§»åŠ¨æ—¶ï¼Œä¸­æ™¯ç§»åŠ¨é€Ÿåº¦ä¸­ç­‰
                let parallaxOffset = (camera.x * PARALLAX_SPEED.mid) % layerWidth;
                if (parallaxOffset < 0) parallaxOffset += layerWidth;
                let drawX = layerX - parallaxOffset;
                
                // æ— ç¼å¾ªç¯ç»˜åˆ¶
                while (drawX < GAME_WIDTH) {
                    ctx.drawImage(
                        backgroundImages.mid,
                        Math.floor(drawX), 
                        layerY,
                        layerWidth, 
                        layerHeight
                    );
                    drawX += layerWidth;
                }
                
                ctx.restore();
            }

            // --- è¿›å…¥ç›¸æœºåæ ‡ç³» ---
            ctx.save();
            ctx.translate(-camera.x, 0);

            // å¦‚æœä½ ä¸æƒ³è¦åŸæœ¬é‚£ä¸ªäº®ç»¿è‰²çš„çŸ©å½¢å—æŒ¡ä½ bg_cï¼Œå¯ä»¥æ³¨é‡Šæ‰ä¸‹é¢è¿™å‡ è¡Œ
            /*
            const groundY = GROUND_Y;
            ctx.fillStyle = 'rgba(39, 174, 96, 0.3)'; // æ”¹ä¸ºé€æ˜ï¼Œæ–¹ä¾¿å¯¹é½
            ctx.fillRect(camera.x, groundY, GAME_WIDTH, GAME_HEIGHT - groundY);
            */

            // ç»˜åˆ¶é™·é˜±ã€çŒ´å­ã€ç©å®¶ç­‰æ¸¸æˆå¯¹è±¡
            // å»ºè®®ï¼šå¦‚æœç©å®¶çœ‹èµ·æ¥"é™·"è¿›äº†åœŸé‡Œï¼Œè¯·å¾®è°ƒ update() é‡Œçš„ groundY

            // ç»˜åˆ¶é™·é˜±ï¼ˆä½¿ç”¨å›¾ç‰‡ï¼‰
            ctx.imageSmoothingEnabled = false;
            if (ctx.imageSmoothingQuality) {
                ctx.imageSmoothingQuality = 'low';
            }
            for (let trap of traps) {
                // æ£€æŸ¥å›¾ç‰‡æ˜¯å¦å·²åŠ è½½
                if (trapImg && trapImg.complete && trapImg.naturalWidth > 0) {
                    ctx.save();
                    ctx.globalCompositeOperation = 'source-over';
                    
                    // ä½¿ç”¨æ•´æ•°åæ ‡ç»˜åˆ¶ï¼Œç¡®ä¿åƒç´ å¯¹é½
                    const drawX = Math.floor(trap.x);
                    const drawY = Math.floor(trap.y);
                    
                    ctx.drawImage(
                        trapImg,
                        drawX, 
                        drawY,
                        trap.width, 
                        trap.height
                    );
                    ctx.restore();
                } else {
                    // å›¾ç‰‡æœªåŠ è½½æ—¶ï¼Œä½¿ç”¨åŸæ¥çš„ç»˜åˆ¶ä½œä¸ºåå¤‡
                    ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(trap.x, trap.y, trap.width, trap.height);
                ctx.strokeStyle = '#c0392b';
                ctx.lineWidth = 3;
                ctx.strokeRect(trap.x, trap.y, trap.width, trap.height);
                }
            }
                
            // ç»˜åˆ¶é¦™è•‰æ ‘ï¼ˆä½¿ç”¨å›¾ç‰‡ï¼‰
            ctx.imageSmoothingEnabled = false;
            if (ctx.imageSmoothingQuality) {
                ctx.imageSmoothingQuality = 'low';
            }
            for (let tree of bananaTrees) {
                // æ£€æŸ¥å›¾ç‰‡æ˜¯å¦å·²åŠ è½½
                if (treeImg && treeImg.complete && treeImg.naturalWidth > 0) {
                    ctx.save();
                    ctx.globalCompositeOperation = 'source-over';
                    
                    // ä½¿ç”¨æ•´æ•°åæ ‡ç»˜åˆ¶ï¼Œç¡®ä¿åƒç´ å¯¹é½
                    const drawX = Math.floor(tree.x);
                    const drawY = Math.floor(tree.y);
                    
                    ctx.drawImage(
                        treeImg,
                        drawX, 
                        drawY,
                        tree.width, 
                        tree.height
                    );
                    
                    // å¦‚æœå·²äº¤äº’ï¼Œæ˜¾ç¤ºåŠé€æ˜é®ç½©
                    if (tree.interacted) {
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                        ctx.fillRect(drawX, drawY, tree.width, tree.height);
                    }
                    ctx.restore();
                } else {
                    // å›¾ç‰‡æœªåŠ è½½æ—¶ï¼Œä½¿ç”¨åŸæ¥çš„ç»˜åˆ¶ä½œä¸ºåå¤‡
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(tree.x + tree.width / 2 - 8, tree.y + tree.height - 20, 16, 20);
                ctx.fillStyle = '#2ecc71';
                ctx.beginPath();
                ctx.arc(tree.x + tree.width / 2, tree.y + tree.height - 30, 25, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
            // ç»˜åˆ¶æ™®é€šçŒ´å­ï¼ˆé˜»ç¢ï¼Œä½¿ç”¨å›¾ç‰‡ï¼‰
            ctx.imageSmoothingEnabled = false;
            if (ctx.imageSmoothingQuality) {
                ctx.imageSmoothingQuality = 'low';
            }
            for (let monkey of normalMonkeys) {
                // æ£€æŸ¥å›¾ç‰‡æ˜¯å¦å·²åŠ è½½
                if (fakeMonkeyImg && fakeMonkeyImg.complete && fakeMonkeyImg.naturalWidth > 0) {
                    ctx.save();
                    ctx.globalCompositeOperation = 'source-over';
                    
                    // ä½¿ç”¨æ•´æ•°åæ ‡ç»˜åˆ¶ï¼Œç¡®ä¿åƒç´ å¯¹é½
                    const drawX = Math.floor(monkey.x);
                    const drawY = Math.floor(monkey.y);
                    
                    ctx.drawImage(
                        fakeMonkeyImg,
                        drawX, 
                        drawY,
                        monkey.width, 
                        monkey.height
                    );
                    ctx.restore();
                } else {
                    // å›¾ç‰‡æœªåŠ è½½æ—¶ï¼Œä½¿ç”¨åŸæ¥çš„çŸ©å½¢ç»˜åˆ¶ä½œä¸ºåå¤‡
                ctx.fillStyle = monkey.color;
                ctx.fillRect(monkey.x, monkey.y, monkey.width, monkey.height);
                
                // çŒ´å­çœ¼ç›
                ctx.fillStyle = '#000';
                ctx.fillRect(monkey.x + 8, monkey.y + 12, 6, 6);
                ctx.fillRect(monkey.x + 31, monkey.y + 12, 6, 6);
                
                // çŒ´å­å˜´å·´
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(monkey.x + monkey.width / 2, monkey.y + 32, 6, 0, Math.PI);
                ctx.stroke();
                }
            }

            // ç»˜åˆ¶ç›®æ ‡çŒ´å­ï¼ˆä½¿ç”¨å›¾ç‰‡ï¼‰
            ctx.imageSmoothingEnabled = false;
            if (ctx.imageSmoothingQuality) {
                ctx.imageSmoothingQuality = 'low';
            }
            
            // æ ¹æ®ç§»åŠ¨çŠ¶æ€é€‰æ‹©å›¾ç‰‡ï¼ˆç§»åŠ¨æ—¶ç”¨runï¼Œé™æ­¢æ—¶ç”¨stayï¼‰
            const targetMonkeySprite = Math.abs(targetMonkey.speedX) > 0.1 
                ? (targetMonkeyRunImg && targetMonkeyRunImg.complete ? targetMonkeyRunImg : targetMonkeyStayImg)
                : targetMonkeyStayImg;
            
            // æ£€æŸ¥å›¾ç‰‡æ˜¯å¦å·²åŠ è½½
            if (targetMonkeySprite && targetMonkeySprite.complete && targetMonkeySprite.naturalWidth > 0) {
                ctx.save();
                ctx.globalCompositeOperation = 'source-over';
                
                // ä½¿ç”¨æ•´æ•°åæ ‡ç»˜åˆ¶ï¼Œç¡®ä¿åƒç´ å¯¹é½
                const drawX = Math.floor(targetMonkey.x);
                const drawY = Math.floor(targetMonkey.y);
                
                ctx.drawImage(
                    targetMonkeySprite,
                    drawX, 
                    drawY,
                    targetMonkey.width, 
                    targetMonkey.height
                );
                ctx.restore();
            } else {
                // å›¾ç‰‡æœªåŠ è½½æ—¶ï¼Œä½¿ç”¨åŸæ¥çš„ç»˜åˆ¶ä½œä¸ºåå¤‡
            ctx.fillStyle = targetMonkey.color;
            ctx.fillRect(targetMonkey.x, targetMonkey.y, targetMonkey.width, targetMonkey.height);
            ctx.fillStyle = '#000';
            ctx.fillRect(targetMonkey.x + 10, targetMonkey.y + 15, 8, 8);
            ctx.fillRect(targetMonkey.x + 32, targetMonkey.y + 15, 8, 8);
            }

            // ç»˜åˆ¶çŒ´å­æŒ‘è¡…æ°”æ³¡
            if (gameState.monkeyTaunt.currentText && gameState.monkeyTaunt.opacity > 0) {
                // ç›´æ¥ä½¿ç”¨ä¸–ç•Œåæ ‡ï¼Œå› ä¸ºå‰é¢å·²ç»æœ‰ ctx.translate(-camera.x, 0)
                const bubbleX = targetMonkey.x + targetMonkey.width / 2;
                const bubbleY = targetMonkey.y - 80 + gameState.monkeyTaunt.floatOffset;
                
                // æµ‹é‡æ–‡å­—å®½åº¦ï¼ˆç”¨äºåŠ¨æ€è°ƒæ•´æ°”æ³¡å¤§å°ï¼‰
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                const textMetrics = ctx.measureText(gameState.monkeyTaunt.currentText);
                const textWidth = textMetrics.width;
                const bubbleWidth = Math.max(180, textWidth + 40);
                const bubbleHeight = 45;
                
                // æ£€æŸ¥æ˜¯å¦åœ¨è§†é‡å†…ï¼ˆå¯é€‰ä¼˜åŒ–ï¼‰
                const viewLeft = camera.x - 100;
                const viewRight = camera.x + GAME_WIDTH + 100;
                
                if (bubbleX >= viewLeft && bubbleX <= viewRight) {
                    // åº”ç”¨é€æ˜åº¦
                    const alpha = gameState.monkeyTaunt.opacity;
                    
                    // ç»˜åˆ¶æ°”æ³¡èƒŒæ™¯ï¼ˆåœ†è§’çŸ©å½¢ï¼‰
                    ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.95})`;
                    ctx.strokeStyle = `rgba(241, 196, 15, ${alpha})`;
                    ctx.lineWidth = 3;
                    
                    // ç»˜åˆ¶åœ†è§’çŸ©å½¢æ°”æ³¡
                    const radius = 12;
                    ctx.beginPath();
                    ctx.moveTo(bubbleX - bubbleWidth / 2 + radius, bubbleY);
                    ctx.lineTo(bubbleX + bubbleWidth / 2 - radius, bubbleY);
                    ctx.quadraticCurveTo(bubbleX + bubbleWidth / 2, bubbleY, bubbleX + bubbleWidth / 2, bubbleY + radius);
                    ctx.lineTo(bubbleX + bubbleWidth / 2, bubbleY + bubbleHeight - radius);
                    ctx.quadraticCurveTo(bubbleX + bubbleWidth / 2, bubbleY + bubbleHeight, bubbleX + bubbleWidth / 2 - radius, bubbleY + bubbleHeight);
                    ctx.lineTo(bubbleX - bubbleWidth / 2 + radius, bubbleY + bubbleHeight);
                    ctx.quadraticCurveTo(bubbleX - bubbleWidth / 2, bubbleY + bubbleHeight, bubbleX - bubbleWidth / 2, bubbleY + bubbleHeight - radius);
                    ctx.lineTo(bubbleX - bubbleWidth / 2, bubbleY + radius);
                    ctx.quadraticCurveTo(bubbleX - bubbleWidth / 2, bubbleY, bubbleX - bubbleWidth / 2 + radius, bubbleY);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    
                    // ç»˜åˆ¶å°ä¸‰è§’å½¢æŒ‡å‘çŒ´å­ï¼ˆæ°”æ³¡åº•éƒ¨ä¸­å¤®ï¼‰
                    ctx.beginPath();
                    ctx.moveTo(bubbleX - 10, bubbleY + bubbleHeight);
                    ctx.lineTo(bubbleX, bubbleY + bubbleHeight + 10);
                    ctx.lineTo(bubbleX + 10, bubbleY + bubbleHeight);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    
                    // ç»˜åˆ¶æ–‡å­—
                    ctx.fillStyle = `rgba(44, 62, 80, ${alpha})`;
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(gameState.monkeyTaunt.currentText, bubbleX, bubbleY + bubbleHeight / 2);
                    ctx.textAlign = 'left';
                    ctx.textBaseline = 'alphabetic';
                }
            }

            // ç»˜åˆ¶ç©å®¶
            // ç¦ç”¨å¹³æ»‘ï¼Œä¿æŒåƒç´ é£
            ctx.imageSmoothingEnabled = false;
            if (ctx.imageSmoothingQuality) {
                ctx.imageSmoothingQuality = 'low';
            }
            
            // é€‰æ‹©å›¾ç‰‡æºï¼šæ ¹æ® isWorking çŠ¶æ€é€‰æ‹©
            const currentHeroSprite = gameState.isWorking ? heroWorkImg : heroStayImg;
            
            // æ£€æŸ¥å›¾ç‰‡æ˜¯å¦å·²åŠ è½½
            if (currentHeroSprite && currentHeroSprite.complete && currentHeroSprite.naturalWidth > 0) {
                ctx.save();
                ctx.globalCompositeOperation = 'source-over';
                
                // ä½¿ç”¨æ•´æ•°åæ ‡ç»˜åˆ¶ï¼Œç¡®ä¿åƒç´ å¯¹é½
                const drawX = Math.floor(player.animX.current);
                const drawY = Math.floor(player.animY.current);
                
                // ä½¿ç”¨åŠ¨ç”»ä½ç½®ç»˜åˆ¶ï¼ˆæ›´å¹³æ»‘è‡ªç„¶ï¼‰
                ctx.drawImage(
                    currentHeroSprite,
                    drawX, 
                    drawY,
                    player.width, 
                    player.height
                );
                ctx.restore();
            } else {
                // å›¾ç‰‡æœªåŠ è½½æ—¶ï¼Œä½¿ç”¨åŸæ¥çš„çŸ©å½¢ç»˜åˆ¶ä½œä¸ºåå¤‡
            ctx.fillStyle = player.color;
                ctx.fillRect(
                    Math.floor(player.animX.current), 
                    Math.floor(player.animY.current), 
                    player.width, 
                    player.height
                );
            
            // ç©å®¶çœ¼ç›
            ctx.fillStyle = '#000';
                ctx.fillRect(
                    Math.floor(player.animX.current) + 10, 
                    Math.floor(player.animY.current) + 15, 
                    6, 6
                );
                ctx.fillRect(
                    Math.floor(player.animX.current) + 24, 
                    Math.floor(player.animY.current) + 15, 
                    6, 6
                );
            
            // ç©å®¶å˜´å·´
            ctx.fillStyle = '#fff';
                ctx.fillRect(
                    Math.floor(player.animX.current) + 15, 
                    Math.floor(player.animY.current) + 25, 
                    10, 3
                );
            
            // ç©å®¶æ‰‹è‡‚ï¼ˆè·³è·ƒæ—¶ï¼‰
            if (!player.onGround) {
                ctx.fillStyle = player.color;
                    ctx.fillRect(
                        Math.floor(player.animX.current) - 5, 
                        Math.floor(player.animY.current) + 20, 
                        8, 15
                    );
                    ctx.fillRect(
                        Math.floor(player.animX.current) + player.width - 3, 
                        Math.floor(player.animY.current) + 20, 
                        8, 15
                    );
                }
            }

            // æ¢å¤ä¸Šä¸‹æ–‡ï¼ˆUIä¸å—ç›¸æœºå½±å“ï¼‰
            ctx.restore();

            // ç»˜åˆ¶UIä¿¡æ¯ï¼ˆå›ºå®šåœ¨å±å¹•ä¸Šï¼‰
            drawUI();
        }

        // ç»˜åˆ¶UIä¿¡æ¯
        function drawUI() {
            // åªç»˜åˆ¶é¦™è•‰æ•°é‡ï¼ˆçªå‡ºæ˜¾ç¤ºï¼Œå°é¢æ¿ï¼Œä¸å½±å“æ¸¸æˆåœºæ™¯ï¼‰
            const bananaPanelWidth = 200;
            const bananaPanelHeight = 80;
            const bananaPanelX = GAME_WIDTH - bananaPanelWidth - 20; // å³ä¸Šè§’
            const bananaPanelY = 20;
            
            // åŠé€æ˜èƒŒæ™¯é¢æ¿ï¼ˆæ›´å°æ›´ç²¾è‡´ï¼‰
            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            ctx.fillRect(bananaPanelX, bananaPanelY, bananaPanelWidth, bananaPanelHeight);
            ctx.strokeStyle = '#f1c40f';
            ctx.lineWidth = 3;
            ctx.strokeRect(bananaPanelX, bananaPanelY, bananaPanelWidth, bananaPanelHeight);
            
            // ç»˜åˆ¶é¦™è•‰æ•°é‡ï¼ˆçªå‡ºæ˜¾ç¤ºï¼‰
            ctx.fillStyle = '#f1c40f';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`ğŸŒ ${gameState.bananas}`, bananaPanelX + bananaPanelWidth / 2, bananaPanelY + 55);
            ctx.textAlign = 'left';
            
            // ç»˜åˆ¶é¦™è•‰æ•°é‡æç¤ºï¼ˆæ¸¸æˆå¼€å§‹å2ç§’å†…æ˜¾ç¤ºï¼‰
            if (gameState.running && !gameState.bananaNotificationShown && gameState.bananaNotificationTimer < 3.0) {
                const currentLevelSettings = LEVEL_SETTINGS.levels[gameState.currentLevel];
                const notificationX = GAME_WIDTH / 2;
                const notificationY = GAME_HEIGHT / 2 - 100;
                
                // æ·¡å…¥æ·¡å‡ºæ•ˆæœ
                const alpha = gameState.bananaNotificationTimer < 0.5 ? gameState.bananaNotificationTimer * 2 :
                             gameState.bananaNotificationTimer > 2.5 ? (3.0 - gameState.bananaNotificationTimer) * 2 : 1.0;
                
                // æç¤ºèƒŒæ™¯
                ctx.fillStyle = `rgba(0, 0, 0, ${0.8 * alpha})`;
                ctx.fillRect(notificationX - 250, notificationY - 40, 500, 80);
                ctx.strokeStyle = `rgba(241, 196, 15, ${alpha})`;
                ctx.lineWidth = 4;
                ctx.strokeRect(notificationX - 250, notificationY - 40, 500, 80);
                
                // æç¤ºæ–‡å­—
                ctx.fillStyle = `rgba(241, 196, 15, ${alpha})`;
                ctx.font = 'bold 36px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`ğŸ® å½“å‰é¦™è•‰æ•°: ${gameState.bananas}`, notificationX, notificationY + 10);
                ctx.textAlign = 'left';
                
                // 3ç§’åæ ‡è®°ä¸ºå·²æ˜¾ç¤º
                if (gameState.bananaNotificationTimer >= 3.0) {
                    gameState.bananaNotificationShown = true;
                }
            }

            // ç»˜åˆ¶æ—¶é—´è­¦å‘Šï¼ˆå¦‚æœçŒ´å­ç¦»å¼€è§†é‡ï¼‰
            if (gameState.running && !isMonkeyInView()) {
                const remainingTime = TIME_SETTINGS.outOfViewTimeLimit - gameState.monkeyOutOfViewTime;
                const timePercent = remainingTime / TIME_SETTINGS.outOfViewTimeLimit;
                
                // æ—¶é—´æ¡èƒŒæ™¯
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(GAME_WIDTH / 2 - 200, 20, 400, 30);
                
                // æ—¶é—´æ¡
                const barColor = remainingTime <= TIME_SETTINGS.warningTime ? '#e74c3c' : '#f39c12';
                ctx.fillStyle = barColor;
                ctx.fillRect(GAME_WIDTH / 2 - 200, 20, 400 * timePercent, 30);
                
                // æ—¶é—´æ¡è¾¹æ¡†
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(GAME_WIDTH / 2 - 200, 20, 400, 30);
                
                // æ—¶é—´æ–‡å­—
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`çŒ´å­é€ƒè„±å€’è®¡æ—¶: ${remainingTime.toFixed(1)}ç§’`, GAME_WIDTH / 2, 42);
                ctx.textAlign = 'left';
                
                // è­¦å‘Šé—ªçƒæ•ˆæœ
                if (remainingTime <= TIME_SETTINGS.warningTime) {
                    const blink = Math.sin(Date.now() / 100) > 0;
                    if (blink) {
                        ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                        ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
                    }
                }
            }

            // ç»˜åˆ¶å¹²æ´»è¿›åº¦æ¡
            if (gameState.isWorking) {
                const progressBarWidth = 300;
                const progressBarHeight = 20;
                const progressBarX = GAME_WIDTH / 2 - progressBarWidth / 2;
                const progressBarY = GAME_HEIGHT / 2 - 100;
                
                // è¿›åº¦æ¡èƒŒæ™¯
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(progressBarX, progressBarY, progressBarWidth, progressBarHeight);
                
                // è¿›åº¦æ¡
                ctx.fillStyle = '#2ecc71';
                ctx.fillRect(progressBarX, progressBarY, progressBarWidth * gameState.workProgress, progressBarHeight);
                
                // è¿›åº¦æ¡è¾¹æ¡†
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(progressBarX, progressBarY, progressBarWidth, progressBarHeight);
                
                // è¿›åº¦æ–‡å­—
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`å¹²æ´»ä¸­... ${Math.floor(gameState.workProgress * 100)}%`, GAME_WIDTH / 2, progressBarY - 10);
                ctx.textAlign = 'left';
            }

            // ç»˜åˆ¶é¢„æ¥è¿‘æç¤ºï¼ˆæå‰æ˜¾ç¤ºï¼‰
            if (gameState.running && gameState.preNearBananaTree && !gameState.nearBananaTree && !gameState.isWorking) {
                const tree = gameState.preNearBananaTree;
                const treeScreenX = tree.x - camera.x;
                const treeScreenY = tree.y - 120;
                
                // æ·¡å…¥æç¤º
                ctx.fillStyle = 'rgba(241, 196, 15, 0.4)';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('å‰æ–¹æœ‰é¦™è•‰æ ‘ ğŸŒ', treeScreenX, treeScreenY);
                ctx.textAlign = 'left';
            }
            
            // ç»˜åˆ¶å¸¸é©»æŒ‰é”®æç¤ºï¼ˆå±å¹•å·¦ä¸‹è§’ï¼Œä½è°ƒæ˜¾ç¤ºï¼Œä»…ç¬¬ä¸€å…³ï¼‰
            if (gameState.running && gameState.currentLevel === 0) {
                const keyHintX = 20;
                const keyHintY = GAME_HEIGHT - 100;
                const keyHintWidth = 180;
                const keyHintHeight = 75;
                
                // åŠé€æ˜èƒŒæ™¯
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(keyHintX, keyHintY, keyHintWidth, keyHintHeight);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.lineWidth = 1;
                ctx.strokeRect(keyHintX, keyHintY, keyHintWidth, keyHintHeight);
                
                // æŒ‰é”®æç¤ºæ–‡å­—
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.font = '14px Arial';
                ctx.textAlign = 'left';
                if (isMobile) {
                    ctx.fillText('â† å‰è¿›', keyHintX + 10, keyHintY + 25);
                    ctx.fillText('â†‘ è·³è·ƒ', keyHintX + 10, keyHintY + 45);
                    ctx.fillText('è§¦æ‘¸äº¤äº’', keyHintX + 10, keyHintY + 65);
                } else {
                    ctx.fillText('D - å‰è¿›', keyHintX + 10, keyHintY + 25);
                    ctx.fillText('W - è·³è·ƒ', keyHintX + 10, keyHintY + 45);
                    ctx.fillText('E/Q - äº¤äº’', keyHintX + 10, keyHintY + 65);
                }
            }
            
            // ç»˜åˆ¶äº¤äº’æç¤ºï¼ˆæ¥è¿‘é¦™è•‰æ ‘æ—¶ï¼‰- è½»é‡çº§æç¤ºï¼Œä¸å¼¹çª—
            if (gameState.running && 
                gameState.nearBananaTree && 
                !gameState.isWorking) {
                const tree = gameState.nearBananaTree;
                const treeScreenX = tree.x - camera.x;
                const treeScreenY = tree.y - 120; // å‘ä¸Šç§»åŠ¨ï¼Œé¿å…é®æŒ¡
                
                // æç¤ºæ¡†å°ºå¯¸ï¼ˆå¢å¤§ï¼‰
                const tipWidth = 350;
                const tipHeight = 140;
                const tipX = treeScreenX - tipWidth / 2;
                const tipY = treeScreenY;
                
                // ç¡®ä¿æç¤ºæ¡†åœ¨å±å¹•å†…
                const adjustedX = Math.max(10, Math.min(tipX, GAME_WIDTH - tipWidth - 10));
                
                // æç¤ºèƒŒæ™¯
                ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
                ctx.fillRect(adjustedX, tipY, tipWidth, tipHeight);
                ctx.strokeStyle = '#f1c40f';
                ctx.lineWidth = 3;
                ctx.strokeRect(adjustedX, tipY, tipWidth, tipHeight);
                
                // æç¤ºæ–‡å­—ï¼ˆå¢å¤§å­—ä½“ï¼‰
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('ğŸŒ é¦™è•‰æ ‘', adjustedX + tipWidth / 2, tipY + 30);
                
                // é€‰é¡¹ï¼ˆå¢å¤§å­—ä½“ï¼‰
                ctx.font = '18px Arial';
                const canSkip = gameState.bananas >= BANANA_SETTINGS.skipCost;
                ctx.fillStyle = canSkip ? '#2ecc71' : '#95a5a6';
                ctx.fillText(`Eé”®: å¹²æ´» (+${BANANA_SETTINGS.workReward}ğŸŒ, ${BANANA_SETTINGS.workTime}ç§’)`, adjustedX + tipWidth / 2, tipY + 65);
                ctx.fillStyle = canSkip ? '#f39c12' : '#95a5a6';
                ctx.fillText(`Qé”®: æŠµæ‰£é¦™è•‰ (-${BANANA_SETTINGS.skipCost}ğŸŒ)`, adjustedX + tipWidth / 2, tipY + 95);
                
                // å¦‚æœé¦™è•‰ä¸è¶³ï¼Œæ˜¾ç¤ºæç¤º
                if (!canSkip) {
                    ctx.fillStyle = '#e74c3c';
                    ctx.font = '14px Arial';
                    ctx.fillText('(é¦™è•‰ä¸è¶³ï¼Œåªèƒ½é€‰æ‹©å¹²æ´»)', adjustedX + tipWidth / 2, tipY + 120);
                }
                
                ctx.textAlign = 'left';
            }

            // ç»˜åˆ¶æ“ä½œè¯´æ˜ï¼ˆå³ä¸‹è§’ï¼Œéç¬¬ä¸€å…³æ—¶æ˜¾ç¤ºï¼‰
            if (gameState.currentLevel > 0) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(GAME_WIDTH - 350, GAME_HEIGHT - 150, 340, isMobile ? 120 : 140);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 2;
                ctx.strokeRect(GAME_WIDTH - 350, GAME_HEIGHT - 150, 340, isMobile ? 120 : 140);

                ctx.fillStyle = '#fff';
                ctx.font = 'bold 18px Arial';
                ctx.fillText('æ“ä½œè¯´æ˜', GAME_WIDTH - 340, GAME_HEIGHT - 125);
                ctx.font = '16px Arial';
                
                if (isMobile) {
                    ctx.fillText('ç‚¹å‡»åº•éƒ¨å·¦ä¾§æŒ‰é’®è·³è·ƒ', GAME_WIDTH - 340, GAME_HEIGHT - 100);
                    ctx.fillText('ç‚¹å‡»åº•éƒ¨å³ä¾§æŒ‰é’®å‰è¿›', GAME_WIDTH - 340, GAME_HEIGHT - 80);
                    ctx.fillText('æ¥è¿‘é¦™è•‰æ ‘æ—¶æ˜¾ç¤ºäº¤äº’æŒ‰é’®', GAME_WIDTH - 340, GAME_HEIGHT - 60);
                } else {
                    ctx.fillText('Dé”®å‰è¿›', GAME_WIDTH - 340, GAME_HEIGHT - 100);
                    ctx.fillText('Wé”®è·³è·ƒ', GAME_WIDTH - 340, GAME_HEIGHT - 80);
                    ctx.fillText('Eé”®å¹²æ´» Qé”®æŠµæ‰£é¦™è•‰', GAME_WIDTH - 340, GAME_HEIGHT - 60);
                }
            }

            // ç»˜åˆ¶è™šæ‹ŸæŒ‰é”®ï¼ˆä»…æ‰‹æœºæ˜¾ç¤ºï¼Œæ¸¸æˆè¿è¡Œæ—¶ï¼‰
            if (isMobile && gameState.running) {
                drawVirtualButtons();
            }

            // ç»˜åˆ¶å¼€å§‹æŒ‰é’®å’Œæ¸¸æˆå¼€å§‹å‰è¯´æ˜ï¼ˆå¦‚æœæ¸¸æˆæœªå¼€å§‹ã€å·²ç»“æŸæˆ–å…³å¡å®Œæˆï¼‰
            if (!gameState.running || gameState.gameOver || gameState.levelComplete) {
                // å¦‚æœæ˜¯ç¬¬ä¸€å…³ä¸”æœªæ˜¾ç¤ºè¿‡è¯´æ˜ï¼Œæ˜¾ç¤ºç®€åŒ–çš„æ“ä½œè¯´æ˜
                if (gameState.currentLevel === 0 && !gameState.tutorialShown.preGameInstructionsShown && !gameState.gameOver) {
                    // åŠé€æ˜èƒŒæ™¯é®ç½©
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
                    ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
                    
                    // è¯´æ˜æ¡†ï¼ˆè°ƒæ•´å°ºå¯¸ï¼Œç¡®ä¿æŒ‰é’®ä¸é®æŒ¡æ–‡å­—ï¼‰
                    const boxWidth = 450;
                    const boxHeight = 320;  // ä»250å¢åŠ åˆ°320ï¼Œç»™æŒ‰é’®ç•™å‡ºç©ºé—´
                    const boxX = GAME_WIDTH / 2 - boxWidth / 2;
                    const boxY = GAME_HEIGHT / 2 - boxHeight / 2;
                    
                    // è¯´æ˜æ¡†èƒŒæ™¯
                    ctx.fillStyle = 'rgba(30, 30, 30, 0.98)';
                    ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
                    ctx.strokeStyle = '#f1c40f';
                    ctx.lineWidth = 4;
                    ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);
                    
                    // æ ‡é¢˜
                    ctx.fillStyle = '#f1c40f';
                    ctx.font = 'bold 28px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('ğŸ® æ“ä½œè¯´æ˜', boxX + boxWidth / 2, boxY + 45);
                    
                    // ç®€åŒ–çš„æ“ä½œè¯´æ˜ï¼ˆåªä¿ç•™æ ¸å¿ƒå†…å®¹ï¼‰
                    ctx.fillStyle = '#fff';
                    ctx.font = '20px Arial';
                    ctx.textAlign = 'left';
                    const instructions = [
                        isMobile ? 'â†‘ åº•éƒ¨å·¦ä¾§æŒ‰é’®ï¼šè·³è·ƒ' : 'Wé”®ï¼šè·³è·ƒ',
                        isMobile ? 'â†’ åº•éƒ¨å³ä¾§æŒ‰é’®ï¼šå‰è¿›' : 'Dé”®ï¼šå‰è¿›',
                        'é¿å¼€çº¢è‰²é™·é˜±',
                        isMobile ? 'æ¥è¿‘é¦™è•‰æ ‘æ—¶ç‚¹å‡»äº¤äº’æŒ‰é’®' : 'Eé”®å¹²æ´» Qé”®æŠµæ‰£é¦™è•‰'
                    ];
                    
                    instructions.forEach((line, index) => {
                        ctx.fillText(line, boxX + 40, boxY + 95 + index * 35);
                    });
                    
                    // å¼€å§‹æŒ‰é’®ï¼ˆå‘ä¸‹ç§»åŠ¨ï¼Œé¿å…é®æŒ¡æ–‡å­—ï¼‰
                    const btnX = boxX + boxWidth / 2 - 100;
                    const btnY = boxY + boxHeight - 70;
                    const btnWidth = 200;
                    const btnHeight = 50;
                    
                    const hoverOffset = (isButtonHovered && !isMobile) ? -2 : 0;
                    ctx.fillStyle = (isButtonHovered && !isMobile) ? '#2980b9' : '#3498db';
                    ctx.fillRect(btnX + hoverOffset, btnY + hoverOffset, btnWidth, btnHeight);
                    ctx.strokeStyle = '#2980b9';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(btnX + hoverOffset, btnY + hoverOffset, btnWidth, btnHeight);
                    
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 24px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('å¼€å§‹æ¸¸æˆ', boxX + boxWidth / 2 + hoverOffset, btnY + 35 + hoverOffset);
                    ctx.textAlign = 'left';
                } else {
                    // æ™®é€šå¼€å§‹/é‡æ–°å¼€å§‹æŒ‰é’®
                    const btnX = GAME_WIDTH / 2 - 100;
                    const btnY = GAME_HEIGHT / 2 + 50;
                    const btnWidth = 200;
                    const btnHeight = 50;

                    const hoverOffset = (isButtonHovered && !isMobile) ? -2 : 0;
                    ctx.fillStyle = (isButtonHovered && !isMobile) ? '#2980b9' : '#3498db';
                    ctx.fillRect(btnX + hoverOffset, btnY + hoverOffset, btnWidth, btnHeight);
                    ctx.strokeStyle = '#2980b9';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(btnX + hoverOffset, btnY + hoverOffset, btnWidth, btnHeight);

                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 24px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(gameState.gameOver ? 'é‡æ–°å¼€å§‹' : 'å¼€å§‹æ¸¸æˆ', GAME_WIDTH / 2 + hoverOffset, btnY + 35 + hoverOffset);
                    ctx.textAlign = 'left';
                }
            }
        }

        // åœ†è§’çŸ©å½¢è¾…åŠ©å‡½æ•°
        function roundRect(ctx, x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
        }

        // ç»˜åˆ¶å•ä¸ªè™šæ‹ŸæŒ‰é’®çš„è¾…åŠ©å‡½æ•°
        function drawVirtualButton(btn, pressed, colorNormal, colorPressed, borderColor, icon, text, disabled = false) {
            const scale = pressed ? 1.1 : 1.0;
            const width = btn.width * scale;
            const height = btn.height * scale;
            const x = btn.x - (width - btn.width) / 2;
            const y = btn.y - (height - btn.height) / 2;
            
            // ç»˜åˆ¶é˜´å½±
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            roundRect(ctx, x + 3, y + 3, width, height, 15);
            ctx.fill();
            
            // ç»˜åˆ¶æŒ‰é’®èƒŒæ™¯ï¼ˆç¦ç”¨æ—¶å˜ç°ï¼‰
            if (disabled) {
                ctx.fillStyle = 'rgba(149, 165, 166, 0.4)';
            } else {
                ctx.fillStyle = pressed ? colorPressed : colorNormal;
            }
            roundRect(ctx, x, y, width, height, 15);
            ctx.fill();
            
            // ç»˜åˆ¶è¾¹æ¡†
            ctx.strokeStyle = disabled ? '#95a5a6' : borderColor;
            ctx.lineWidth = 3;
            roundRect(ctx, x, y, width, height, 15);
            ctx.stroke();
            
            // ç»˜åˆ¶å›¾æ ‡å’Œæ–‡å­—
            ctx.fillStyle = disabled ? '#7f8c8d' : '#fff';
            ctx.font = 'bold 28px Arial';
            ctx.textAlign = 'center';
            if (icon) {
                ctx.fillText(icon, x + width / 2, y + height / 2 - 5);
            }
            if (text) {
                ctx.font = 'bold 16px Arial';
                ctx.fillText(text, x + width / 2, y + height / 2 + 20);
            }
        }

        // ç»˜åˆ¶è™šæ‹ŸæŒ‰é”®ï¼ˆæ‰‹æœºï¼‰- ä¼˜åŒ–ç‰ˆï¼šåº•éƒ¨æ§åˆ¶æ¡ï¼Œåœ†è§’ã€é˜´å½±ã€æŒ‰ä¸‹æ•ˆæœ
        function drawVirtualButtons() {
            // ç»˜åˆ¶åº•éƒ¨æ§åˆ¶æ¡èƒŒæ™¯ï¼ˆåŠé€æ˜ï¼‰
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(0, GAME_HEIGHT - 100, GAME_WIDTH, 100);
            
            // æ£€æŸ¥æ˜¯å¦æ¥è¿‘é¦™è•‰æ ‘
            const showTreeButtons = gameState.nearBananaTree && 
                                   !gameState.isWorking && 
                                   !gameState.nearBananaTree.interacted;
            const canSkip = gameState.bananas >= BANANA_SETTINGS.skipCost;
            
            // è·³è·ƒæŒ‰é’®ï¼ˆå·¦ä¾§ï¼‰
            drawVirtualButton(
                virtualButtonPositions.jump,
                virtualButtons.jump,
                'rgba(46, 204, 113, 0.6)',
                'rgba(46, 204, 113, 0.9)',
                '#2ecc71',
                'â†‘',
                null,
                false
            );
            
            // å¦‚æœæ¥è¿‘é¦™è•‰æ ‘ï¼Œæ˜¾ç¤ºå¹²æ´»å’Œè·³è¿‡æŒ‰é’®
            if (showTreeButtons) {
                // å¹²æ´»æŒ‰é’®ï¼ˆä¸­é—´åå·¦ï¼‰
                drawVirtualButton(
                    virtualButtonPositions.work,
                    virtualButtons.work,
                    'rgba(46, 204, 113, 0.6)',
                    'rgba(46, 204, 113, 0.9)',
                    '#2ecc71',
                    'ğŸŒ',
                    `+${BANANA_SETTINGS.workReward}`,
                    false
                );
                
                // è·³è¿‡æŒ‰é’®ï¼ˆä¸­é—´åå³ï¼‰
                drawVirtualButton(
                    virtualButtonPositions.skip,
                    virtualButtons.skip,
                    'rgba(231, 76, 60, 0.6)',
                    'rgba(231, 76, 60, 0.9)',
                    '#e74c3c',
                    'â­',
                    `-${BANANA_SETTINGS.skipCost}`,
                    !canSkip  // é¦™è•‰ä¸è¶³æ—¶ç¦ç”¨
                );
            }
            
            // å‰è¿›æŒ‰é’®ï¼ˆå³ä¾§ï¼‰
            drawVirtualButton(
                virtualButtonPositions.right,
                virtualButtons.right,
                'rgba(52, 152, 219, 0.6)',
                'rgba(52, 152, 219, 0.9)',
                '#3498db',
                'â†’',
                null,
                false
            );
            
            ctx.textAlign = 'left';
        }

        // ç»˜åˆ¶äº‘æœµ
        function drawCloud(x, y) {
            ctx.beginPath();
            ctx.arc(x, y, 20, 0, Math.PI * 2);
            ctx.arc(x + 25, y, 30, 0, Math.PI * 2);
            ctx.arc(x + 50, y, 20, 0, Math.PI * 2);
            ctx.fill();
        }

        // æ¸¸æˆå¾ªç¯
        let lastTime = 0;
        function gameLoop(timestamp) {
            if (!lastTime) lastTime = timestamp;
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;

            // é™åˆ¶å¸§ç‡ï¼Œç¡®ä¿æ¸¸æˆé€»è¾‘ç¨³å®š
            if (deltaTime >= 16) { // çº¦60fps
                update();
                draw();
            }
            
            requestAnimationFrame(gameLoop);
        }

        // æ˜¾ç¤ºå…³å¡å®Œæˆç•Œé¢
        function showLevelComplete(rating) {
            gameOverlay.classList.add('show');
            
            // æ ¹æ®è¯„çº§æ˜¾ç¤ºä¸åŒçš„çŒ´å­è¡¨æƒ…
            let monkeyEmoji = 'ğŸ’'; // é»˜è®¤
            if (rating.level === 3) {
                monkeyEmoji = 'ğŸŸ¡ğŸ’'; // ä¸‰çº§çŒ´å­
            } else if (rating.level === 2) {
                monkeyEmoji = 'âšªğŸ’'; // äºŒçº§çŒ´å­
            } else {
                monkeyEmoji = 'ğŸŸ¤ğŸ’'; // ä¸€çº§çŒ´å­
            }
            
            // éšæœºé€‰æ‹©ä¸€æ¡æ¶ˆæ¯
            const randomMessage = rating.messages[Math.floor(Math.random() * rating.messages.length)];
            
            // æ˜¾ç¤ºçŒ´å­å½¢è±¡å’Œè¯­æ–™åº“æ¶ˆæ¯
            overlayMessage.innerHTML = `
                <div style="font-size: 4em; margin-bottom: 20px;">${monkeyEmoji}</div>
                <div style="font-size: 1.2em; margin: 15px 0; line-height: 1.8; color: #fff; text-shadow: 1px 1px 2px rgba(0,0,0,0.5);">
                    ${randomMessage}
                </div>
            `;
            overlayMessage.className = 'overlay-message victory';
        }

        // è¿›å…¥ä¸‹ä¸€å…³
        function proceedToNextLevel() {
            // æ£€æŸ¥æ˜¯å¦è¿˜æœ‰ä¸‹ä¸€å…³
            if (gameState.currentLevel >= LEVEL_SETTINGS.levels.length - 1) {
                // å·²ç»æ˜¯æœ€åä¸€å…³ï¼Œæ˜¾ç¤ºé€šå…³ç•Œé¢
                showGameOver(true, 'complete');
                return;
            }
            
            // è®¡ç®—è¯„çº§å¥–åŠ±
            const rating = RATING_SYSTEM.getRating(gameState.bananas);
            const bonusBananas = rating.bonus;
            
            // è¿›å…¥ä¸‹ä¸€å…³
            gameState.currentLevel++;
            gameState.levelComplete = false;
            gameState.levelCompleteTime = 0;
            gameState.victory = false;
            gameState.running = true;
            
            // é‡ç½®éšœç¢ç‰©ç”Ÿæˆé¡ºåºï¼ˆæ–°å…³å¡é‡æ–°å¼€å§‹èŠ‚å¥ï¼‰
            gameState.obstacleSequenceIndex = 0;
            
            // é‡ç½®çŒ´å­æŒ‘è¡…çŠ¶æ€
            gameState.monkeyTaunt.currentText = '';
            gameState.monkeyTaunt.distanceLevel = 'far';
            gameState.monkeyTaunt.displayTime = 0;
            gameState.monkeyTaunt.waitTime = 0;
            gameState.monkeyTaunt.isWaiting = false;
            gameState.monkeyTaunt.opacity = 0;
            gameState.monkeyTaunt.floatOffset = 0;
            gameState.gameOver = false;
            gameState.levelBananasReceived = false;
            gameState.dynamicMonkeySpawnTimer = 0; // é‡ç½®åŠ¨æ€çŒ´å­è®¡æ—¶å™¨
            // æˆåŠŸè¿›å…¥ä¸‹ä¸€å…³ï¼Œæ¸…é™¤å¤±è´¥å…³å¡è®°å½•
            gameState.failedLevel = null;
            
            // æ·»åŠ è¯„çº§å¥–åŠ±
            if (bonusBananas > 0) {
                gameState.bananas += bonusBananas;
                console.log(`è·å¾—è¯„çº§å¥–åŠ±ï¼š+${bonusBananas}ğŸŒ`);
            }
            
            // é‡ç½®ç©å®¶å’ŒçŒ´å­ä½ç½®ï¼ˆä¿æŒç›¸å¯¹ä½ç½®ï¼‰
            const levelSettings = LEVEL_SETTINGS.levels[gameState.currentLevel];
            const newStartX = levelSettings.startDistance * 10; // è½¬æ¢ä¸ºåƒç´ 
            
            player.x = newStartX + 100;
            player.y = GAME_HEIGHT - 200;
            // é‡ç½®åŠ¨ç”»ä½ç½®
            player.animX = { current: player.x, velocity: 0 };
            player.animY = { current: player.y, velocity: 0 };
            player.speedX = 0;
            player.speedY = 0;
            
            targetMonkey.x = newStartX + 500;
            targetMonkey.y = GAME_HEIGHT - 200;
            targetMonkey.speedX = 5;  // ä»4å¢åŠ åˆ°5ï¼ŒåŸºç¡€é€Ÿåº¦æ›´å¿«
            targetMonkey.speedY = 0;
            targetMonkey.onGround = true;
            
            // æ›´æ–°ä¸–ç•Œåæ ‡
            worldX = newStartX;
            camera.x = newStartX;
            camera.targetX = newStartX;
            
            // é‡ç½®ç”Ÿæˆä½ç½®ï¼ˆç»™ç©å®¶ä¸€ä¸ªå®‰å…¨åŒºåŸŸï¼Œä¸åœ¨ç©å®¶é™„è¿‘ç”Ÿæˆé™·é˜±ï¼‰
            // ç©å®¶åœ¨newStartX+100ï¼ŒçŒ´å­åœ¨newStartX+500ï¼Œæ‰€ä»¥ä»newStartX+600å¼€å§‹ç”Ÿæˆé™·é˜±
            const safeZone = 600; // å®‰å…¨åŒºåŸŸï¼ˆåƒç´ ï¼‰
            lastTrapX = newStartX + safeZone;
            lastTreeX = newStartX + safeZone;
            lastNormalMonkeyX = newStartX + safeZone;
            
            // æ¸…ç†æ—§éšœç¢ç‰©
            traps.length = 0;
            bananaTrees.length = 0;
            normalMonkeys.length = 0;
            
            // ç”Ÿæˆæ–°å…³å¡çš„éšœç¢ç‰©ï¼ˆä»å®‰å…¨åŒºåŸŸä¹‹åå¼€å§‹ï¼‰
            const generateStartX = newStartX + safeZone;
            const generateEndX = newStartX + safeZone + trapGenerationDistance;
            generateTraps(generateStartX, generateEndX);
            generateBananaTrees(generateStartX, generateEndX);
            generateNormalMonkeys(generateStartX, generateEndX);
            
            // éšè—å®Œæˆç•Œé¢
            gameOverlay.classList.remove('show');
            
            // é‡ç½®é¦™è•‰æ ‘äº¤äº’çŠ¶æ€
            for (let tree of bananaTrees) {
                tree.interacted = false;
            }
            
            console.log(`è¿›å…¥${levelSettings.name}ï¼Œå‘æ”¾${levelSettings.bananaReward}ä¸ªé¦™è•‰`);
        }

        // æ˜¾ç¤ºæ¸¸æˆç»“æŸç•Œé¢
        function showGameOver(victory, reason) {
            gameOverlay.classList.add('show');
            if (victory) {
                if (reason === 'complete') {
                    overlayMessage.innerHTML = `
                        <div style="font-size: 1.8em; margin-bottom: 20px;">ğŸ† æ­å–œé€šå…³ï¼ğŸ†</div>
                        <div style="font-size: 1.3em; margin: 15px 0; line-height: 1.6;">
                            ä½ æˆåŠŸå®Œæˆäº†æ‰€æœ‰å…³å¡ï¼<br/>
                            æˆä¸ºäº†çœŸæ­£çš„é‡‡è•‰å¤§å¸ˆï¼<br/>
                            æ‰€æœ‰çŒ´å­éƒ½è¢«ä½ å¾æœäº†ï¼ğŸ‘‘
                        </div>
                        <div style="font-size: 1.1em; margin: 10px 0; opacity: 0.9;">
                            ğŸŒ æœ€ç»ˆé¦™è•‰æ•°ï¼š${gameState.bananas}
                        </div>
                        <div style="font-size: 0.9em; margin-top: 20px; opacity: 0.7; font-style: italic;">
                            ç‚¹å‡»é‡æ–°å¼€å§‹æŒ‰é’®ç»§ç»­æ¸¸æˆ
                        </div>
                    `;
                    // é€šå…³åæ¸…é™¤å¤±è´¥å…³å¡è®°å½•
                    gameState.failedLevel = null;
                } else {
                    overlayMessage.textContent = 'ğŸ‰ æ­å–œï¼ä½ æŠ“ä½äº†çŒ´å­ï¼ğŸ‰';
                }
                overlayMessage.className = 'overlay-message victory';
            } else {
                // è®°å½•å¤±è´¥æ—¶çš„å…³å¡ï¼Œä»¥ä¾¿é‡æ–°å¼€å§‹æ—¶ä»è¯¥å…³å¡å¼€å§‹
                gameState.failedLevel = gameState.currentLevel;
                
                // ä½¿ç”¨éšæœºå¤±è´¥æ¶ˆæ¯
                const failureMessage = getRandomFailureMessage(reason);
                overlayMessage.innerHTML = `
                    <div style="font-size: 1.4em; margin-bottom: 15px; line-height: 1.6; color: #fff; text-shadow: 1px 1px 2px rgba(0,0,0,0.5);">
                        ${failureMessage}
                    </div>
                    <div style="font-size: 1em; margin-top: 15px; opacity: 0.8;">
                        ğŸŒ æ”¶é›†äº† ${gameState.bananas} ä¸ªé¦™è•‰
                    </div>
                    <div style="font-size: 0.9em; margin-top: 20px; opacity: 0.7; font-style: italic;">
                        ç‚¹å‡»é‡æ–°å¼€å§‹æŒ‰é’®å†æ¥ä¸€æ¬¡
                    </div>
                `;
                overlayMessage.className = 'overlay-message defeat';
            }
        }

        // å¼€å§‹æ¸¸æˆ
        function startGame() {
            gameState.running = true;
            gameState.gameOver = false;
            gameState.victory = false;
            gameState.score = 0;
            gameState.distance = 0;
            gameState.bananas = 0; // é‡ç½®é¦™è•‰æ•°é‡ï¼ˆç”±å…³å¡å‘æ”¾ï¼‰
            gameState.monkeyOutOfViewTime = 0; // é‡ç½®æ—¶é—´
            gameState.isWorking = false; // é‡ç½®å¹²æ´»çŠ¶æ€
            gameState.workProgress = 0; // é‡ç½®å¹²æ´»è¿›åº¦
            gameState.nearBananaTree = null; // é‡ç½®æ¥è¿‘çš„é¦™è•‰æ ‘
            gameState.preNearBananaTree = null; // é‡ç½®é¢„æ¥è¿‘çš„é¦™è•‰æ ‘
            
            // å¦‚æœæœ‰å¤±è´¥å…³å¡è®°å½•ï¼Œä»å¤±è´¥å…³å¡å¼€å§‹ï¼Œå¦åˆ™ä»ç¬¬ä¸€å…³å¼€å§‹
            if (gameState.failedLevel !== null && gameState.failedLevel >= 0 && gameState.failedLevel < LEVEL_SETTINGS.levels.length) {
                gameState.currentLevel = gameState.failedLevel;
            } else {
                gameState.currentLevel = 0;
            }
            
            gameState.lastLevelChangeDistance = 0; // é‡ç½®å…³å¡åˆ‡æ¢è·ç¦»
            gameState.levelBananasReceived = false; // é‡ç½®é¦™è•‰å‘æ”¾æ ‡å¿—
            gameState.levelComplete = false; // é‡ç½®å…³å¡å®ŒæˆçŠ¶æ€
            gameState.levelCompleteTime = 0; // é‡ç½®å…³å¡å®Œæˆæ—¶é—´
            gameState.dynamicMonkeySpawnTimer = 0; // é‡ç½®åŠ¨æ€çŒ´å­è®¡æ—¶å™¨

            // åˆå§‹åŒ–é€Ÿåº¦å€æ•°å’ŒåŸºç¡€é€Ÿåº¦
            gameState.speedMultiplier = 1.0;
            gameState.baseMaxSpeed = 8;  // ç©å®¶åŸºç¡€é€Ÿåº¦
            gameState.baseMonkeySpeed = 5; // çŒ´å­åŸºç¡€é€Ÿåº¦
            player.maxSpeed = gameState.baseMaxSpeed;
            targetMonkey.speedX = gameState.baseMonkeySpeed;
            
            // é‡ç½®éšœç¢ç‰©ç”Ÿæˆé¡ºåº
            gameState.obstacleSequenceIndex = 0;
            
            // é‡ç½®çŒ´å­æŒ‘è¡…çŠ¶æ€
            gameState.monkeyTaunt.currentText = '';
            gameState.monkeyTaunt.distanceLevel = 'far';
            gameState.monkeyTaunt.displayTime = 0;
            gameState.monkeyTaunt.waitTime = 0;
            gameState.monkeyTaunt.isWaiting = false;
            gameState.monkeyTaunt.opacity = 0;
            gameState.monkeyTaunt.floatOffset = 0;
            
            // é‡ç½®å¼•å¯¼çŠ¶æ€ï¼ˆåªåœ¨ç¬¬ä¸€å…³æ—¶é‡ç½®ï¼‰
            if (gameState.currentLevel === 0) {
                gameState.tutorialShown = {
                    firstBananaTree: false,
                    preGameInstructionsShown: false
                };
            }
            
            // é‡ç½®é¦™è•‰æç¤º
            gameState.bananaNotificationTimer = 0;
            gameState.bananaNotificationShown = false;
            
            // æ ¹æ®å…³å¡è®¾ç½®åˆå§‹ä½ç½®
            const levelSettings = LEVEL_SETTINGS.levels[gameState.currentLevel];
            const startX = levelSettings.startDistance * 10; // è½¬æ¢ä¸ºåƒç´ 
            
            // é‡ç½®ä¸–ç•Œåæ ‡å’Œç›¸æœº
            worldX = startX;
            camera.x = startX;
            camera.targetX = startX;
            
            // é‡ç½®ç©å®¶ä½ç½®ï¼ˆåœ¨çŒ´å­åé¢ï¼‰
            player.x = startX + 100;
            player.y = GAME_HEIGHT - 200;
            // é‡ç½®åŠ¨ç”»ä½ç½®
            player.animX = { current: player.x, velocity: 0 };
            player.animY = { current: player.y, velocity: 0 };
            player.speedX = 0;
            player.speedY = 0;
            
            // é‡ç½®çŒ´å­ä½ç½®ï¼ˆåœ¨ç©å®¶å‰é¢ï¼‰
            targetMonkey.x = startX + 500;
            targetMonkey.y = GAME_HEIGHT - 200;
            targetMonkey.speedX = 5;  // ä»4å¢åŠ åˆ°5ï¼ŒåŸºç¡€é€Ÿåº¦æ›´å¿«
            targetMonkey.speedY = 0;
            targetMonkey.onGround = true;
            
            // é‡ç½®ç”Ÿæˆä½ç½®ï¼ˆç»™ç©å®¶ä¸€ä¸ªå®‰å…¨åŒºåŸŸï¼‰
            const safeZone = 600; // å®‰å…¨åŒºåŸŸï¼ˆåƒç´ ï¼‰
            lastTrapX = startX + safeZone;
            lastTreeX = startX + safeZone;
            lastNormalMonkeyX = startX + safeZone;
            
            // æ¸…ç†æ—§éšœç¢ç‰©
            traps.length = 0;
            bananaTrees.length = 0;
            normalMonkeys.length = 0;
            
            // åˆå§‹åŒ–é™·é˜±ï¼ˆä»å®‰å…¨åŒºåŸŸä¹‹åå¼€å§‹ï¼‰
            const generateStartX = startX + safeZone;
            const generateEndX = generateStartX + trapGenerationDistance;
            generateTraps(generateStartX, generateEndX);
            
            // åˆå§‹åŒ–é¦™è•‰æ ‘ï¼ˆä»å®‰å…¨åŒºåŸŸä¹‹åå¼€å§‹ï¼‰
            generateBananaTrees(generateStartX, generateEndX);
            
            // åˆå§‹åŒ–æ™®é€šçŒ´å­ï¼ˆä»å®‰å…¨åŒºåŸŸä¹‹åå¼€å§‹ï¼‰
            generateNormalMonkeys(generateStartX, generateEndX);
            
            // é‡ç½®è™šæ‹ŸæŒ‰é”®çŠ¶æ€
            virtualButtons.right = false;
            virtualButtons.jump = false;
            virtualButtons.work = false;
            virtualButtons.skip = false;
            activeTouches = {};
            
            gameOverlay.classList.remove('show');
            
            console.log(`æ¸¸æˆå·²å¼€å§‹ï¼Œä»${levelSettings.name}å¼€å§‹`);
        }

        // é‡æ–°å¼€å§‹æ¸¸æˆ
        function restartGame() {
            startGame();
        }

        // å¯åŠ¨æ¸¸æˆå¾ªç¯
        requestAnimationFrame(gameLoop);

        // åˆå§‹åŒ–
        loadBackgroundImages(); // åŠ è½½èƒŒæ™¯å›¾ç‰‡
        initTraps();
        console.log('æ¸¸æˆåˆå§‹åŒ–å®Œæˆï¼Œç”»å¸ƒå°ºå¯¸:', GAME_WIDTH, 'x', GAME_HEIGHT);
        console.log('è®¾å¤‡ç±»å‹:', isMobile ? 'ç§»åŠ¨è®¾å¤‡' : 'ç”µè„‘');
    </script>
</body>
</html>