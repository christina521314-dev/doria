<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æŠ“è•‰çŒ´ - æ¸¸æˆDemo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        .game-container {
            background: #2c3e50;
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 1200px;
            width: 95%;
        }

        .game-header {
            text-align: center;
            color: #fff;
            margin-bottom: 20px;
        }

        .game-header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            color: #fff;
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        .game-canvas-wrapper {
            position: relative;
            background: #87CEEB;
            border: 4px solid #34495e;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.3);
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 500px;
        }

        .controls {
            margin-top: 20px;
            text-align: center;
            color: #fff;
        }

        .controls h3 {
            margin-bottom: 10px;
        }

        .control-buttons {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
        }

        .btn {
            padding: 12px 24px;
            font-size: 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            background: #3498db;
            color: white;
            transition: all 0.3s;
            font-weight: bold;
        }

        .btn:hover {
            background: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .btn:active {
            transform: translateY(0);
        }

        .game-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            color: white;
            font-size: 2em;
            z-index: 100;
            border-radius: 10px;
        }

        .game-overlay.show {
            display: flex;
        }

        .overlay-message {
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .victory {
            color: #f1c40f;
        }

        .defeat {
            color: #e74c3c;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-header">
            <h1>ğŸ’ æŠ“è•‰çŒ´ ğŸŒ</h1>
        </div>
        <div class="game-info">
            <div>å¾—åˆ†: <span id="score">0</span></div>
            <div>è·ç¦»: <span id="distance">0</span>m</div>
            <div>çŠ¶æ€: <span id="status">æ¸¸æˆä¸­</span></div>
        </div>
        <div class="game-canvas-wrapper">
            <canvas id="gameCanvas"></canvas>
            <div class="game-overlay" id="gameOverlay">
                <div class="overlay-message" id="overlayMessage"></div>
                <button class="btn" onclick="restartGame()">é‡æ–°å¼€å§‹</button>
            </div>
        </div>
        <div class="controls">
            <h3>æ“ä½œè¯´æ˜</h3>
            <p>â† â†’ æ–¹å‘é”®ç§»åŠ¨ | ç©ºæ ¼é”®è·³è·ƒ</p>
            <div class="control-buttons">
                <button class="btn" onclick="startGame()">å¼€å§‹æ¸¸æˆ</button>
                <button class="btn" onclick="pauseGame()">æš‚åœ</button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameOverlay = document.getElementById('gameOverlay');
        const overlayMessage = document.getElementById('overlayMessage');
        const scoreElement = document.getElementById('score');
        const distanceElement = document.getElementById('distance');
        const statusElement = document.getElementById('status');

        // å›ºå®šæ¸¸æˆé€»è¾‘å°ºå¯¸
        const GAME_WIDTH = 1280;
        const GAME_HEIGHT = 720;

        // è®¾ç½®ç”»å¸ƒå°ºå¯¸ï¼ˆå›ºå®šä¸ºæ¸¸æˆé€»è¾‘å°ºå¯¸ï¼‰
        function resizeCanvas() {
            canvas.width = GAME_WIDTH;
            canvas.height = GAME_HEIGHT;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // ç›¸æœºç³»ç»Ÿï¼ˆç”¨äºç”»é¢æ»šåŠ¨å’Œè§†å·®æ•ˆæœï¼‰
        const camera = {
            x: 0,
            y: 0,
            targetX: 0,
            followSpeed: 0.1
        };

        // èƒŒæ™¯å›¾ç‰‡å¯¹è±¡
        const backgroundImages = {
            far: null,    // è¿œæ™¯ bg_d
            mid: null,    // ä¸­æ™¯ bg_m
            near: null    // è¿‘æ™¯ bg_c
        };

        // è§†å·®æ»šåŠ¨é€Ÿåº¦ç³»æ•°ï¼ˆç›¸å¯¹äºç›¸æœºç§»åŠ¨é€Ÿåº¦ï¼‰
        const PARALLAX_SPEED = {
            far: 0.2,    // è¿œæ™¯æœ€æ…¢ï¼ˆç§»åŠ¨20%ï¼‰
            mid: 0.5,    // ä¸­æ™¯ä¸­ç­‰ï¼ˆç§»åŠ¨50%ï¼‰
            near: 0.8    // è¿‘æ™¯æœ€å¿«ï¼ˆç§»åŠ¨80%ï¼‰
        };

        // èƒŒæ™¯å›¾ç‰‡å¯¹é½åç§»é…ç½®ï¼ˆç”¨äºè°ƒæ•´å¤©ç©ºå’Œé“è·¯ä½ç½®ï¼‰
        // åœ°é¢ä½ç½®ï¼šGAME_HEIGHT - 100 = 620ï¼ˆåœ¨ç»˜åˆ¶å‡½æ•°ä¸­å®šä¹‰ï¼‰
        // è°ƒæ•´è¯´æ˜ï¼š
        //   - offsetX: Xè½´åç§»ï¼Œæ­£æ•°å‘å³ç§»åŠ¨ï¼Œè´Ÿæ•°å‘å·¦ç§»åŠ¨
        //   - offsetY: Yè½´åç§»ï¼Œæ­£æ•°å‘ä¸‹ç§»åŠ¨ï¼Œè´Ÿæ•°å‘ä¸Šç§»åŠ¨
        //   - è¿‘æ™¯é“è·¯è¦å¯¹é½åˆ°åœ°é¢(620)ï¼Œå¦‚æœå›¾ç‰‡é«˜åº¦720ï¼Œåˆ™offsetYçº¦-100ï¼ˆå›¾ç‰‡åº•éƒ¨å¯¹é½åœ°é¢ï¼‰
        //   - å¯ä»¥æ ¹æ®å®é™…å›¾ç‰‡å°ºå¯¸å’Œå¯¹é½éœ€æ±‚è°ƒæ•´è¿™äº›å€¼
        const BACKGROUND_OFFSET = {
            far: { x: 0, y: 0 },    // è¿œæ™¯åç§»ï¼ˆç¬¬220è¡Œé…ç½®ï¼‰- è°ƒæ•´X/Yåæ ‡
            mid: { x: 0, y: 0 },    // ä¸­æ™¯åç§»ï¼ˆç¬¬221è¡Œé…ç½®ï¼‰- è°ƒæ•´X/Yåæ ‡
            near: { x: 0, y: -100 } // è¿‘æ™¯åç§»ï¼ˆç¬¬222è¡Œé…ç½®ï¼‰- è´Ÿå€¼å‘ä¸Šï¼Œè®©é“è·¯å¯¹é½åœ°é¢
        };

        // åŠ è½½èƒŒæ™¯å›¾ç‰‡
        function loadBackgroundImages() {
            backgroundImages.far = new Image();
            backgroundImages.far.src = 'bg_d.png';  // è¿œæ™¯å›¾ç‰‡
            
            backgroundImages.mid = new Image();
            backgroundImages.mid.src = 'bg_m.png';  // ä¸­æ™¯å›¾ç‰‡
            
            backgroundImages.near = new Image();
            backgroundImages.near.src = 'bg_c.png';  // è¿‘æ™¯å›¾ç‰‡
            
            // æ·»åŠ åŠ è½½å®Œæˆå›è°ƒ
            let loadedCount = 0;
            const totalImages = 3;
            
            function onImageLoad() {
                loadedCount++;
                console.log(`èƒŒæ™¯å›¾ç‰‡åŠ è½½æˆåŠŸ (${loadedCount}/${totalImages})`);
                if (loadedCount === totalImages) {
                    console.log('æ‰€æœ‰èƒŒæ™¯å›¾ç‰‡åŠ è½½å®Œæˆ');
                }
            }
            
            backgroundImages.far.onload = onImageLoad;
            backgroundImages.mid.onload = onImageLoad;
            backgroundImages.near.onload = onImageLoad;
            
            // åŠ è½½å¤±è´¥æ—¶çš„å¤„ç†
            backgroundImages.far.onerror = (e) => {
                console.error('è¿œæ™¯å›¾ç‰‡(bg_d.png)åŠ è½½å¤±è´¥:', e);
                console.error('è¯·ç¡®è®¤æ–‡ä»¶æ˜¯å¦å­˜åœ¨ä¸”è·¯å¾„æ­£ç¡®');
            };
            backgroundImages.mid.onerror = (e) => {
                console.error('ä¸­æ™¯å›¾ç‰‡(bg_m.png)åŠ è½½å¤±è´¥:', e);
                console.error('è¯·ç¡®è®¤æ–‡ä»¶æ˜¯å¦å­˜åœ¨ä¸”è·¯å¾„æ­£ç¡®');
            };
            backgroundImages.near.onerror = (e) => {
                console.error('è¿‘æ™¯å›¾ç‰‡(bg_c.png)åŠ è½½å¤±è´¥:', e);
                console.error('è¯·ç¡®è®¤æ–‡ä»¶æ˜¯å¦å­˜åœ¨ä¸”è·¯å¾„æ­£ç¡®');
            };
        }

        // åˆå§‹åŒ–æ—¶åŠ è½½èƒŒæ™¯å›¾ç‰‡
        loadBackgroundImages();

        // æ¸¸æˆçŠ¶æ€
        let gameState = {
            running: false,
            paused: false,
            gameOver: false,
            victory: false,
            score: 0,
            distance: 0
        };

        // ç©å®¶å¯¹è±¡
        const player = {
            x: 100,
            y: 300,
            width: 40,
            height: 60,
            speedX: 0,
            speedY: 0,
            onGround: false,
            jumpPower: -15,
            gravity: 0.8,
            maxSpeed: 8,
            color: '#3498db'
        };

        // ç›®æ ‡çŒ´å­å¯¹è±¡
        const targetMonkey = {
            x: 800,
            y: 300,
            width: 50,
            height: 60,
            speedX: -2,
            color: '#f39c12',
            hasBanana: true
        };

        // é™·é˜±æ•°ç»„
        const traps = [];
        const trapWidth = 80;
        const trapHeight = 20;

        // åˆå§‹åŒ–é™·é˜±
        function initTraps() {
            traps.length = 0;
            for (let i = 0; i < 5; i++) {
                traps.push({
                    x: 300 + i * 200,
                    y: GAME_HEIGHT - 50,
                    width: trapWidth,
                    height: trapHeight,
                    color: '#e74c3c'
                });
            }
        }

        // é”®ç›˜æ§åˆ¶
        const keys = {};
        window.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if (e.code === 'Space') {
                e.preventDefault();
                if (player.onGround && gameState.running && !gameState.paused) {
                    player.speedY = player.jumpPower;
                    player.onGround = false;
                }
            }
        });

        window.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });

        // ç¢°æ’æ£€æµ‹
        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }

        // æ£€æŸ¥ç©å®¶æ˜¯å¦æ‰å…¥é™·é˜±
        function checkTrapCollision() {
            for (let trap of traps) {
                if (checkCollision(player, trap)) {
                    return true;
                }
            }
            return false;
        }

        // æ£€æŸ¥æ˜¯å¦è¿½ä¸ŠçŒ´å­
        function checkVictory() {
            const distance = Math.abs(player.x - targetMonkey.x);
            return distance < 30 && Math.abs(player.y - targetMonkey.y) < 40;
        }

        // æ›´æ–°æ¸¸æˆé€»è¾‘
        function update() {
            if (!gameState.running || gameState.paused || gameState.gameOver) {
                return;
            }

            // ç©å®¶ç§»åŠ¨
            if (keys['ArrowLeft'] || keys['KeyA']) {
                player.speedX = -player.maxSpeed;
            } else if (keys['ArrowRight'] || keys['KeyD']) {
                player.speedX = player.maxSpeed;
            } else {
                player.speedX *= 0.8; // æ‘©æ“¦åŠ›
            }

            // é‡åŠ›
            player.speedY += player.gravity;
            player.y += player.speedY;

            // åœ°é¢ç¢°æ’
            const groundY = GAME_HEIGHT - 100;
            if (player.y + player.height >= groundY) {
                player.y = groundY - player.height;
                player.speedY = 0;
                player.onGround = true;
            } else {
                player.onGround = false;
            }

            // æ›´æ–°ç©å®¶ä½ç½®
            player.x += player.speedX;

            // è¾¹ç•Œé™åˆ¶ï¼ˆå…è®¸ç©å®¶è¶…å‡ºå±å¹•å³ä¾§ï¼Œç”¨äºæ»šåŠ¨ï¼‰
            if (player.x < 0) player.x = 0;

            // ç›¸æœºè·Ÿéšç©å®¶ï¼ˆå½“ç©å®¶è¶…è¿‡å±å¹•ä¸­å¿ƒæ—¶ï¼‰
            const screenCenterX = GAME_WIDTH / 2;
            if (player.x > screenCenterX) {
                camera.targetX = player.x - screenCenterX;
            } else {
                camera.targetX = 0;
            }
            // å¹³æ»‘è·Ÿéš
            camera.x += (camera.targetX - camera.x) * camera.followSpeed;

            // æ›´æ–°ç›®æ ‡çŒ´å­ä½ç½®
            targetMonkey.y = groundY - targetMonkey.height;
            targetMonkey.x += targetMonkey.speedX;
            // çŒ´å­å¯ä»¥è¶…å‡ºå±å¹•ï¼Œè®©ç›¸æœºè·Ÿéšå¤„ç†
            if (targetMonkey.x + targetMonkey.width < camera.x) {
                targetMonkey.x = camera.x + GAME_WIDTH + 100;
            }

            // æ£€æŸ¥ç¢°æ’
            if (checkTrapCollision()) {
                gameState.gameOver = true;
                gameState.running = false;
                showGameOver(false);
            }

            // æ£€æŸ¥èƒœåˆ©
            if (checkVictory()) {
                gameState.victory = true;
                gameState.gameOver = true;
                gameState.running = false;
                gameState.score += 1000;
                showGameOver(true);
            }

            // æ›´æ–°åˆ†æ•°å’Œè·ç¦»
            gameState.distance = Math.floor((player.x - 100) / 10);
            if (player.onGround && player.speedX !== 0) {
                gameState.score += 1;
            }
            updateUI();
        }

        // ç»˜åˆ¶æ¸¸æˆ
        function draw() {
            // ä¿å­˜ä¸Šä¸‹æ–‡çŠ¶æ€ï¼ˆä¸åº”ç”¨ç›¸æœºåç§»ç»˜åˆ¶èƒŒæ™¯ï¼‰
            ctx.save();
            
            // ç»˜åˆ¶è¿œæ™¯ï¼ˆæœ€æ…¢ï¼Œåœ¨æœ€åº•å±‚ï¼‰
            if (backgroundImages.far && backgroundImages.far.complete && backgroundImages.far.naturalWidth > 0) {
                const imgWidth = backgroundImages.far.naturalWidth || GAME_WIDTH;
                const imgHeight = backgroundImages.far.naturalHeight || GAME_HEIGHT;
                const farOffsetX = camera.x * PARALLAX_SPEED.far;
                const farX = -(farOffsetX % imgWidth) + BACKGROUND_OFFSET.far.x;
                const farY = BACKGROUND_OFFSET.far.y;
                
                // ç»˜åˆ¶è¿œæ™¯å›¾ç‰‡ï¼ˆæ— ç¼å¾ªç¯ï¼Œç¡®ä¿è¦†ç›–æ•´ä¸ªç”»å¸ƒï¼‰
                let drawX = farX;
                while (drawX < GAME_WIDTH) {
                    ctx.drawImage(
                        backgroundImages.far,
                        drawX, farY,
                        imgWidth, imgHeight
                    );
                    drawX += imgWidth;
                }
            } else {
                // å¦‚æœå›¾ç‰‡æœªåŠ è½½ï¼Œä½¿ç”¨åŸæœ‰çš„å¤©ç©ºè‰²
                ctx.fillStyle = '#87CEEB';
                ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            }
            
            // ç»˜åˆ¶ä¸­æ™¯ï¼ˆä¸­ç­‰é€Ÿåº¦ï¼Œåœ¨ä¸­é—´å±‚ï¼‰
            if (backgroundImages.mid && backgroundImages.mid.complete && backgroundImages.mid.naturalWidth > 0) {
                ctx.save();
                ctx.globalAlpha = 0.95; // ç¨å¾®é€æ˜ï¼Œè®©è¿œæ™¯å¯è§
                const imgWidth = backgroundImages.mid.naturalWidth || GAME_WIDTH;
                const imgHeight = backgroundImages.mid.naturalHeight || GAME_HEIGHT;
                const midOffsetX = camera.x * PARALLAX_SPEED.mid;
                const midX = -(midOffsetX % imgWidth) + BACKGROUND_OFFSET.mid.x;
                const midY = BACKGROUND_OFFSET.mid.y;
                
                // ç»˜åˆ¶ä¸­æ™¯å›¾ç‰‡ï¼ˆæ— ç¼å¾ªç¯ï¼‰
                let drawX = midX;
                while (drawX < GAME_WIDTH) {
                    ctx.drawImage(
                        backgroundImages.mid,
                        drawX, midY,
                        imgWidth, imgHeight
                    );
                    drawX += imgWidth;
                }
                ctx.restore();
            }
            
            // ç»˜åˆ¶è¿‘æ™¯ï¼ˆæœ€å¿«é€Ÿåº¦ï¼Œåœ¨æœ€ä¸Šå±‚ï¼Œä½†åœ¨åœ°é¢ä»¥ä¸‹ï¼‰
            if (backgroundImages.near && backgroundImages.near.complete && backgroundImages.near.width > 0) {
                ctx.save();
                ctx.globalAlpha = 0.98;
                const nearOffsetX = camera.x * PARALLAX_SPEED.near;
                const nearX = -(nearOffsetX % (backgroundImages.near.width || GAME_WIDTH)) + BACKGROUND_OFFSET.near.x;
                const nearY = BACKGROUND_OFFSET.near.y;
                
                // ç»˜åˆ¶è¿‘æ™¯å›¾ç‰‡
                ctx.drawImage(
                    backgroundImages.near,
                    nearX, nearY,
                    backgroundImages.near.width || GAME_WIDTH,
                    backgroundImages.near.height || GAME_HEIGHT
                );
                // æ— ç¼å¾ªç¯
                if (nearX + (backgroundImages.near.width || GAME_WIDTH) < GAME_WIDTH) {
                    ctx.drawImage(
                        backgroundImages.near,
                        nearX + (backgroundImages.near.width || GAME_WIDTH), nearY,
                        backgroundImages.near.width || GAME_WIDTH,
                        backgroundImages.near.height || GAME_HEIGHT
                    );
                }
                ctx.restore();
            }

            ctx.restore();

            // åº”ç”¨ç›¸æœºåç§»ï¼ˆä¹‹åçš„æ¸¸æˆå¯¹è±¡ä¼šè·Ÿéšç›¸æœºï¼‰
            ctx.translate(-camera.x, 0);

            // ç»˜åˆ¶åœ°é¢ï¼ˆåœ¨è¿‘æ™¯ä¹‹åï¼Œä½†åœ¨æ¸¸æˆå¯¹è±¡ä¹‹å‰ï¼‰
            const groundY = GAME_HEIGHT - 100;
            const groundStartX = Math.floor(camera.x / 100) * 100 - 100;
            const groundEndX = camera.x + GAME_WIDTH + 100;
            
            ctx.fillStyle = '#27ae60';
            ctx.fillRect(groundStartX, groundY, groundEndX - groundStartX, GAME_HEIGHT - groundY);

            // ç»˜åˆ¶è‰åœ°çº¹ç†
            ctx.fillStyle = '#2ecc71';
            for (let i = groundStartX; i < groundEndX; i += 20) {
                ctx.fillRect(i, groundY, 10, 5);
            }

            // ç»˜åˆ¶é™·é˜±
            ctx.fillStyle = '#e74c3c';
            for (let trap of traps) {
                ctx.fillRect(trap.x, trap.y, trap.width, trap.height);
                // é™·é˜±è¾¹ç¼˜
                ctx.strokeStyle = '#c0392b';
                ctx.lineWidth = 2;
                ctx.strokeRect(trap.x, trap.y, trap.width, trap.height);
            }

            // ç»˜åˆ¶ç›®æ ‡çŒ´å­
            ctx.fillStyle = targetMonkey.color;
            ctx.fillRect(targetMonkey.x, targetMonkey.y, targetMonkey.width, targetMonkey.height);
            
            // çŒ´å­çœ¼ç›
            ctx.fillStyle = '#000';
            ctx.fillRect(targetMonkey.x + 10, targetMonkey.y + 15, 8, 8);
            ctx.fillRect(targetMonkey.x + 32, targetMonkey.y + 15, 8, 8);
            
            // é¦™è•‰
            if (targetMonkey.hasBanana) {
                ctx.fillStyle = '#f1c40f';
                ctx.beginPath();
                ctx.arc(targetMonkey.x + 25, targetMonkey.y - 10, 12, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#d4ac0d';
                ctx.beginPath();
                ctx.arc(targetMonkey.x + 25, targetMonkey.y - 10, 8, 0, Math.PI * 2);
                ctx.fill();
            }

            // ç»˜åˆ¶ç©å®¶
            ctx.fillStyle = player.color;
            ctx.fillRect(player.x, player.y, player.width, player.height);
            
            // ç©å®¶çœ¼ç›
            ctx.fillStyle = '#000';
            ctx.fillRect(player.x + 10, player.y + 15, 6, 6);
            ctx.fillRect(player.x + 24, player.y + 15, 6, 6);
            
            // ç©å®¶æ‰‹è‡‚ï¼ˆè·³è·ƒæ—¶ï¼‰
            if (!player.onGround) {
                ctx.fillStyle = player.color;
                ctx.fillRect(player.x - 5, player.y + 20, 8, 15);
                ctx.fillRect(player.x + player.width - 3, player.y + 20, 8, 15);
            }
        }

        // æ¸¸æˆå¾ªç¯
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // æ˜¾ç¤ºæ¸¸æˆç»“æŸç•Œé¢
        function showGameOver(victory) {
            gameOverlay.classList.add('show');
            if (victory) {
                overlayMessage.textContent = 'ğŸ‰ æ­å–œï¼ä½ æŠ“ä½äº†çŒ´å­ï¼ğŸ‰';
                overlayMessage.className = 'overlay-message victory';
                statusElement.textContent = 'èƒœåˆ©';
            } else {
                overlayMessage.textContent = 'ğŸ’€ æ¸¸æˆç»“æŸï¼æ‰å…¥é™·é˜±äº†ï¼ğŸ’€';
                overlayMessage.className = 'overlay-message defeat';
                statusElement.textContent = 'å¤±è´¥';
            }
        }

        // æ›´æ–°UI
        function updateUI() {
            scoreElement.textContent = gameState.score;
            distanceElement.textContent = gameState.distance;
        }

        // å¼€å§‹æ¸¸æˆ
        function startGame() {
            gameState.running = true;
            gameState.paused = false;
            gameState.gameOver = false;
            gameState.victory = false;
            gameState.score = 0;
            gameState.distance = 0;
            
            // é‡ç½®ç©å®¶ä½ç½®
            player.x = 100;
            player.y = 300;
            player.speedX = 0;
            player.speedY = 0;
            
            // é‡ç½®çŒ´å­ä½ç½®
            targetMonkey.x = 800;
            targetMonkey.y = 300;
            
            // åˆå§‹åŒ–é™·é˜±
            initTraps();
            
            gameOverlay.classList.remove('show');
            statusElement.textContent = 'æ¸¸æˆä¸­';
            updateUI();
        }

        // æš‚åœæ¸¸æˆ
        function pauseGame() {
            if (gameState.running && !gameState.gameOver) {
                gameState.paused = !gameState.paused;
                statusElement.textContent = gameState.paused ? 'å·²æš‚åœ' : 'æ¸¸æˆä¸­';
            }
        }

        // é‡æ–°å¼€å§‹æ¸¸æˆ
        function restartGame() {
            startGame();
        }

        // å¯åŠ¨æ¸¸æˆå¾ªç¯
        gameLoop();

        // åˆå§‹åŒ–
        initTraps();
    </script>
</body>
</html>